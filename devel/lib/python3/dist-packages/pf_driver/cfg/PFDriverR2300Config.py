## *********************************************************
##
## File autogenerated for the pf_driver package
## by the dynamic_reconfigure package.
## Please do not edit.
##
## ********************************************************/

from dynamic_reconfigure.encoding import extract_params

inf = float('inf')

config_description = {'name': 'Default', 'type': '', 'state': True, 'cstate': 'true', 'id': 0, 'parent': 0, 'parameters': [{'name': 'ip_mode', 'type': 'str', 'default': 'autoip', 'level': 1, 'description': 'ip_mode value determines the method used by the device to determine its own IP and network conﬁguration.', 'min': '', 'max': '', 'srcline': 291, 'srcfile': '/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py', 'edit_method': "{'enum': [{'name': 'static', 'type': 'str', 'value': 'static', 'srcline': 11, 'srcfile': '/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2300.cfg', 'description': 'Static IP mode', 'ctype': 'std::string', 'cconsttype': 'const char * const'}, {'name': 'dhcp', 'type': 'str', 'value': 'dhcp', 'srcline': 12, 'srcfile': '/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2300.cfg', 'description': 'DHCP IP mode', 'ctype': 'std::string', 'cconsttype': 'const char * const'}, {'name': 'autoip', 'type': 'str', 'value': 'autoip', 'srcline': 13, 'srcfile': '/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2300.cfg', 'description': 'AutoIP mode', 'ctype': 'std::string', 'cconsttype': 'const char * const'}], 'enum_description': 'An enum to set IP mode'}", 'ctype': 'std::string', 'cconsttype': 'const char * const'}, {'name': 'ip_address', 'type': 'str', 'default': '10.0.10.76', 'level': 2, 'description': 'IP address', 'min': '', 'max': '', 'srcline': 291, 'srcfile': '/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py', 'edit_method': '', 'ctype': 'std::string', 'cconsttype': 'const char * const'}, {'name': 'subnet_mask', 'type': 'str', 'default': '255.0.0.0', 'level': 3, 'description': 'IP netmask', 'min': '', 'max': '', 'srcline': 291, 'srcfile': '/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py', 'edit_method': '', 'ctype': 'std::string', 'cconsttype': 'const char * const'}, {'name': 'gateway', 'type': 'str', 'default': '0.0.0.0', 'level': 4, 'description': 'IP gateway', 'min': '', 'max': '', 'srcline': 291, 'srcfile': '/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py', 'edit_method': '', 'ctype': 'std::string', 'cconsttype': 'const char * const'}, {'name': 'user_tag', 'type': 'str', 'default': 'OMD10M-R2300', 'level': 5, 'description': 'Short UTF8 string for user purposes, up to 32 bytes not chars! (32 chars on R2000)', 'min': '', 'max': '', 'srcline': 291, 'srcfile': '/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py', 'edit_method': '', 'ctype': 'std::string', 'cconsttype': 'const char * const'}, {'name': 'layer_enable', 'type': 'str', 'default': 'on,on,on,on', 'level': 6, 'description': 'An on or off value for each of the layers indexed 0..3 determines whether measurement takes place in that layer. When setting, specify the values as comma-separated list.', 'min': '', 'max': '', 'srcline': 291, 'srcfile': '/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py', 'edit_method': "{'enum': [{'name': 'on_on_on_on', 'type': 'str', 'value': 'on,on,on,on', 'srcline': 21, 'srcfile': '/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2300.cfg', 'description': '', 'ctype': 'std::string', 'cconsttype': 'const char * const'}, {'name': 'on_on_on_off', 'type': 'str', 'value': 'on,on,on,off', 'srcline': 22, 'srcfile': '/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2300.cfg', 'description': '', 'ctype': 'std::string', 'cconsttype': 'const char * const'}, {'name': 'on_on_off_on', 'type': 'str', 'value': 'on,on,off,on', 'srcline': 23, 'srcfile': '/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2300.cfg', 'description': '', 'ctype': 'std::string', 'cconsttype': 'const char * const'}, {'name': 'on_on_off_off', 'type': 'str', 'value': 'on,on,off,off', 'srcline': 24, 'srcfile': '/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2300.cfg', 'description': '', 'ctype': 'std::string', 'cconsttype': 'const char * const'}, {'name': 'on_off_on_on', 'type': 'str', 'value': 'on,off,on,on', 'srcline': 25, 'srcfile': '/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2300.cfg', 'description': '', 'ctype': 'std::string', 'cconsttype': 'const char * const'}, {'name': 'on_off_on_off', 'type': 'str', 'value': 'on,off,on,off', 'srcline': 26, 'srcfile': '/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2300.cfg', 'description': '', 'ctype': 'std::string', 'cconsttype': 'const char * const'}, {'name': 'on_off_off_on', 'type': 'str', 'value': 'on,off,off,on', 'srcline': 27, 'srcfile': '/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2300.cfg', 'description': '', 'ctype': 'std::string', 'cconsttype': 'const char * const'}, {'name': 'on_off_off_off', 'type': 'str', 'value': 'on,off,off,off', 'srcline': 28, 'srcfile': '/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2300.cfg', 'description': '', 'ctype': 'std::string', 'cconsttype': 'const char * const'}, {'name': 'off_on_on_on', 'type': 'str', 'value': 'off,on,on,on', 'srcline': 29, 'srcfile': '/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2300.cfg', 'description': '', 'ctype': 'std::string', 'cconsttype': 'const char * const'}, {'name': 'off_on_on_off', 'type': 'str', 'value': 'off,on,on,off', 'srcline': 30, 'srcfile': '/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2300.cfg', 'description': '', 'ctype': 'std::string', 'cconsttype': 'const char * const'}, {'name': 'off_on_off_on', 'type': 'str', 'value': 'off,on,off,on', 'srcline': 31, 'srcfile': '/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2300.cfg', 'description': '', 'ctype': 'std::string', 'cconsttype': 'const char * const'}, {'name': 'off_on_off_off', 'type': 'str', 'value': 'off,on,off,off', 'srcline': 32, 'srcfile': '/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2300.cfg', 'description': '', 'ctype': 'std::string', 'cconsttype': 'const char * const'}, {'name': 'off_off_on_on', 'type': 'str', 'value': 'off,off,on,on', 'srcline': 33, 'srcfile': '/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2300.cfg', 'description': '', 'ctype': 'std::string', 'cconsttype': 'const char * const'}, {'name': 'off_off_on_off', 'type': 'str', 'value': 'off,off,on,off', 'srcline': 34, 'srcfile': '/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2300.cfg', 'description': '', 'ctype': 'std::string', 'cconsttype': 'const char * const'}, {'name': 'off_off_off_on', 'type': 'str', 'value': 'off,off,off,on', 'srcline': 35, 'srcfile': '/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2300.cfg', 'description': '', 'ctype': 'std::string', 'cconsttype': 'const char * const'}, {'name': 'off_off_off_off', 'type': 'str', 'value': 'off,off,off,off', 'srcline': 36, 'srcfile': '/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2300.cfg', 'description': '', 'ctype': 'std::string', 'cconsttype': 'const char * const'}], 'enum_description': 'An enum to set layers'}", 'ctype': 'std::string', 'cconsttype': 'const char * const'}, {'name': 'scan_frequency', 'type': 'int', 'default': 100, 'level': 7, 'description': 'The scan_frequency determines the number of scans taken per second. A scan means a contiguous set of measurements taken within range measure_start_angle to measure_stop_angle. Changing the scan_frequency to either 50 or 100 Hz as a side effect also determines the angular resolution: 0.1° at 50 Hz or 0.2° at 100 Hz.', 'min': -2147483648, 'max': 2147483647, 'srcline': 291, 'srcfile': '/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py', 'edit_method': '', 'ctype': 'int', 'cconsttype': 'const int'}, {'name': 'scan_direction', 'type': 'str', 'default': 'ccw', 'level': 8, 'description': "The scan_direction may allow to change the direction of scanning and therefore also the order of the measurements (direction of ﬁrst measurement) in time. Currently, the setting is ﬁxed to 'ccw' (counter-clockwise, mathematically positive), and 'cw' (clockwise) is not really supported.", 'min': '', 'max': '', 'srcline': 291, 'srcfile': '/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py', 'edit_method': '', 'ctype': 'std::string', 'cconsttype': 'const char * const'}, {'name': 'measure_start_angle', 'type': 'double', 'default': -500000.0, 'level': 9, 'description': 'measure_start_angle (unit: 1/10000 degree) limits the scanning range at one end, while measure_stop_angle determines the other end limit. Scans consist of all samples exactly at and between those two limits, taken at angles rounded to multiples of the current angular resolution as determined by scan_frequency. This is a persistent setting, kept in persistent memory. For dynamic selection of measurement range without wearing out parameter memory, it is recommended to utilize the Scan output options start_angle and max_num_points_scan instead.', 'min': -500000.0, 'max': 500000.0, 'srcline': 291, 'srcfile': '/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py', 'edit_method': '', 'ctype': 'double', 'cconsttype': 'const double'}, {'name': 'measure_stop_angle', 'type': 'double', 'default': 500000.0, 'level': 10, 'description': 'See measure_start_angle for description', 'min': -500000.0, 'max': 500000.0, 'srcline': 291, 'srcfile': '/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py', 'edit_method': '', 'ctype': 'double', 'cconsttype': 'const double'}, {'name': 'locator_indication', 'type': 'str', 'default': 'off', 'level': 11, 'description': 'Enable locator indication (on/off)', 'min': '', 'max': '', 'srcline': 291, 'srcfile': '/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py', 'edit_method': "{'enum': [{'name': 'locator_on', 'type': 'str', 'value': 'on', 'srcline': 44, 'srcfile': '/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2300.cfg', 'description': '', 'ctype': 'std::string', 'cconsttype': 'const char * const'}, {'name': 'locator_off', 'type': 'str', 'value': 'off', 'srcline': 45, 'srcfile': '/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2300.cfg', 'description': '', 'ctype': 'std::string', 'cconsttype': 'const char * const'}], 'enum_description': 'An enum to set locator indicator'}", 'ctype': 'std::string', 'cconsttype': 'const char * const'}, {'name': 'pilot_laser', 'type': 'str', 'default': 'off', 'level': 12, 'description': 'General on or off switch for the red pilot laser. Its actual visibility (in current scanners) is further limited to the range in which measurement takes place, i.e. from measure_start_angle to measure_stop_angle, and also depends on the value of layer_enable.', 'min': '', 'max': '', 'srcline': 291, 'srcfile': '/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py', 'edit_method': "{'enum': [{'name': 'pilot_on', 'type': 'str', 'value': 'on', 'srcline': 49, 'srcfile': '/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2300.cfg', 'description': '', 'ctype': 'std::string', 'cconsttype': 'const char * const'}, {'name': 'pilot_off', 'type': 'str', 'value': 'off', 'srcline': 50, 'srcfile': '/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2300.cfg', 'description': '', 'ctype': 'std::string', 'cconsttype': 'const char * const'}], 'enum_description': 'An enum to set pilot laser'}", 'ctype': 'std::string', 'cconsttype': 'const char * const'}, {'name': 'pilot_start_angle', 'type': 'double', 'default': -500000.0, 'level': 13, 'description': 'Angle where to enable red pilot laser', 'min': -500000.0, 'max': 500000.0, 'srcline': 291, 'srcfile': '/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py', 'edit_method': '', 'ctype': 'double', 'cconsttype': 'const double'}, {'name': 'pilot_stop_angle', 'type': 'double', 'default': 500000.0, 'level': 14, 'description': 'Angle where to disable red pilot laser', 'min': -500000.0, 'max': 500000.0, 'srcline': 291, 'srcfile': '/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py', 'edit_method': '', 'ctype': 'double', 'cconsttype': 'const double'}, {'name': 'operating_mode', 'type': 'str', 'default': 'measure', 'level': 15, 'description': 'The operating_mode, always measure after power on, can be temporarily set to emitter_off to disable the laser pulse, e.g. in order to avoid affecting other scanners.', 'min': '', 'max': '', 'srcline': 291, 'srcfile': '/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py', 'edit_method': "{'enum': [{'name': 'measure', 'type': 'str', 'value': 'measure', 'srcline': 56, 'srcfile': '/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2300.cfg', 'description': 'measure mode', 'ctype': 'std::string', 'cconsttype': 'const char * const'}, {'name': 'emitter_off', 'type': 'str', 'value': 'emitter_off', 'srcline': 57, 'srcfile': '/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2300.cfg', 'description': 'emitter_off mode', 'ctype': 'std::string', 'cconsttype': 'const char * const'}], 'enum_description': 'An enum to set operating mode'}", 'ctype': 'std::string', 'cconsttype': 'const char * const'}, {'name': 'address', 'type': 'str', 'default': '', 'level': 16, 'description': 'When initiating scan data output, request_handle_udp must be given an IPv4 address and port in order to know where to send scandata to. The IPv4 typically should be the IP address of the host who also initiates the connection, e.g. 10.0.10.10, the port something like 6464.', 'min': '', 'max': '', 'srcline': 291, 'srcfile': '/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py', 'edit_method': '', 'ctype': 'std::string', 'cconsttype': 'const char * const'}, {'name': 'port', 'type': 'int', 'default': 0, 'level': 17, 'description': 'See address', 'min': -2147483648, 'max': 2147483647, 'srcline': 291, 'srcfile': '/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py', 'edit_method': '', 'ctype': 'int', 'cconsttype': 'const int'}, {'name': 'packet_type', 'type': 'str', 'default': 'C1', 'level': 18, 'description': 'Packet type for scan data output (always C1 on R2300)', 'min': '', 'max': '', 'srcline': 291, 'srcfile': '/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py', 'edit_method': '', 'ctype': 'std::string', 'cconsttype': 'const char * const'}, {'name': 'packet_crc', 'type': 'str', 'default': '', 'level': 19, 'description': 'Append extra CRC32 for scan data integrity check (currenty always none on R2300)', 'min': '', 'max': '', 'srcline': 291, 'srcfile': '/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py', 'edit_method': '', 'ctype': 'std::string', 'cconsttype': 'const char * const'}, {'name': 'watchdog', 'type': 'str', 'default': 'off', 'level': 20, 'description': "Cease scan data output if watchdog isn't fed in time (always off on R2300)", 'min': '', 'max': '', 'srcline': 291, 'srcfile': '/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py', 'edit_method': '', 'ctype': 'std::string', 'cconsttype': 'const char * const'}, {'name': 'watchdogtimeout', 'type': 'int', 'default': 0, 'level': 21, 'description': 'Maximum time for client to feed watchdog', 'min': -2147483648, 'max': 2147483647, 'srcline': 291, 'srcfile': '/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py', 'edit_method': '', 'ctype': 'int', 'cconsttype': 'const int'}, {'name': 'start_angle', 'type': 'double', 'default': -500000.0, 'level': 22, 'description': "Specifying a start_angle (in 1/10000 degree) allows to reduce the output of data. ∗ While device global settings measure_start_angle and measure_stop_angle determine the range where actual measurements (and laser pulses) take place, start_angle may be used to tell the scanner to include only a subset of the data (starting at or after start_angle) in the scan output. This is provided for compatibility with R2000, where more than one consumer might want different portions of the data, and so you don't have to dynamically update measure_start_angle continuously just to get another range output. The default is -1800000, which means all data.", 'min': -500000.0, 'max': inf, 'srcline': 291, 'srcfile': '/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py', 'edit_method': '', 'ctype': 'double', 'cconsttype': 'const double'}, {'name': 'max_num_points_scan', 'type': 'int', 'default': 0, 'level': 23, 'description': 'Specifying a max_num_points_scan (in 1/10000 degree) allows to reduce the output of data to the given number of measurements (or less if there are less in actual scan range). The default is 0, meaning all data. Note that the same number of measurements may cover double (or half) the angular range dependent on device global setting scan_frequency and thus angular resolution.', 'min': 0, 'max': 2147483647, 'srcline': 291, 'srcfile': '/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py', 'edit_method': '', 'ctype': 'int', 'cconsttype': 'const int'}, {'name': 'skip_scans', 'type': 'int', 'default': 0, 'level': 24, 'description': 'Omit this number of scans (x layers) between output (always 0)', 'min': 0, 'max': 2147483647, 'srcline': 291, 'srcfile': '/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py', 'edit_method': '', 'ctype': 'int', 'cconsttype': 'const int'}], 'groups': [], 'srcline': 246, 'srcfile': '/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py', 'class': 'DEFAULT', 'parentclass': '', 'parentname': 'Default', 'field': 'default', 'upper': 'DEFAULT', 'lower': 'groups'}

min = {}
max = {}
defaults = {}
level = {}
type = {}
all_level = 0

#def extract_params(config):
#    params = []
#    params.extend(config['parameters'])
#    for group in config['groups']:
#        params.extend(extract_params(group))
#    return params

for param in extract_params(config_description):
    min[param['name']] = param['min']
    max[param['name']] = param['max']
    defaults[param['name']] = param['default']
    level[param['name']] = param['level']
    type[param['name']] = param['type']
    all_level = all_level | param['level']

PFDriverR2300_static = 'static'
PFDriverR2300_dhcp = 'dhcp'
PFDriverR2300_autoip = 'autoip'
PFDriverR2300_on_on_on_on = 'on,on,on,on'
PFDriverR2300_on_on_on_off = 'on,on,on,off'
PFDriverR2300_on_on_off_on = 'on,on,off,on'
PFDriverR2300_on_on_off_off = 'on,on,off,off'
PFDriverR2300_on_off_on_on = 'on,off,on,on'
PFDriverR2300_on_off_on_off = 'on,off,on,off'
PFDriverR2300_on_off_off_on = 'on,off,off,on'
PFDriverR2300_on_off_off_off = 'on,off,off,off'
PFDriverR2300_off_on_on_on = 'off,on,on,on'
PFDriverR2300_off_on_on_off = 'off,on,on,off'
PFDriverR2300_off_on_off_on = 'off,on,off,on'
PFDriverR2300_off_on_off_off = 'off,on,off,off'
PFDriverR2300_off_off_on_on = 'off,off,on,on'
PFDriverR2300_off_off_on_off = 'off,off,on,off'
PFDriverR2300_off_off_off_on = 'off,off,off,on'
PFDriverR2300_off_off_off_off = 'off,off,off,off'
PFDriverR2300_locator_on = 'on'
PFDriverR2300_locator_off = 'off'
PFDriverR2300_pilot_on = 'on'
PFDriverR2300_pilot_off = 'off'
PFDriverR2300_measure = 'measure'
PFDriverR2300_emitter_off = 'emitter_off'
