//#line 2 "/opt/ros/noetic/share/dynamic_reconfigure/cmake/../templates/ConfigType.h.template"
// *********************************************************
//
// File autogenerated for the pf_driver package
// by the dynamic_reconfigure package.
// Please do not edit.
//
// ********************************************************/

#ifndef __pf_driver__PFDRIVERR2300CONFIG_H__
#define __pf_driver__PFDRIVERR2300CONFIG_H__

#if __cplusplus >= 201103L
#define DYNAMIC_RECONFIGURE_FINAL final
#else
#define DYNAMIC_RECONFIGURE_FINAL
#endif

#include <dynamic_reconfigure/config_tools.h>
#include <limits>
#include <ros/node_handle.h>
#include <dynamic_reconfigure/ConfigDescription.h>
#include <dynamic_reconfigure/ParamDescription.h>
#include <dynamic_reconfigure/Group.h>
#include <dynamic_reconfigure/config_init_mutex.h>
#include <boost/any.hpp>

namespace pf_driver
{
  class PFDriverR2300ConfigStatics;

  class PFDriverR2300Config
  {
  public:
    class AbstractParamDescription : public dynamic_reconfigure::ParamDescription
    {
    public:
      AbstractParamDescription(std::string n, std::string t, uint32_t l,
          std::string d, std::string e)
      {
        name = n;
        type = t;
        level = l;
        description = d;
        edit_method = e;
      }
      virtual ~AbstractParamDescription() = default;

      virtual void clamp(PFDriverR2300Config &config, const PFDriverR2300Config &max, const PFDriverR2300Config &min) const = 0;
      virtual void calcLevel(uint32_t &level, const PFDriverR2300Config &config1, const PFDriverR2300Config &config2) const = 0;
      virtual void fromServer(const ros::NodeHandle &nh, PFDriverR2300Config &config) const = 0;
      virtual void toServer(const ros::NodeHandle &nh, const PFDriverR2300Config &config) const = 0;
      virtual bool fromMessage(const dynamic_reconfigure::Config &msg, PFDriverR2300Config &config) const = 0;
      virtual void toMessage(dynamic_reconfigure::Config &msg, const PFDriverR2300Config &config) const = 0;
      virtual void getValue(const PFDriverR2300Config &config, boost::any &val) const = 0;
    };

    typedef boost::shared_ptr<AbstractParamDescription> AbstractParamDescriptionPtr;
    typedef boost::shared_ptr<const AbstractParamDescription> AbstractParamDescriptionConstPtr;

    // Final keyword added to class because it has virtual methods and inherits
    // from a class with a non-virtual destructor.
    template <class T>
    class ParamDescription DYNAMIC_RECONFIGURE_FINAL : public AbstractParamDescription
    {
    public:
      ParamDescription(std::string a_name, std::string a_type, uint32_t a_level,
          std::string a_description, std::string a_edit_method, T PFDriverR2300Config::* a_f) :
        AbstractParamDescription(a_name, a_type, a_level, a_description, a_edit_method),
        field(a_f)
      {}

      T PFDriverR2300Config::* field;

      virtual void clamp(PFDriverR2300Config &config, const PFDriverR2300Config &max, const PFDriverR2300Config &min) const override
      {
        if (config.*field > max.*field)
          config.*field = max.*field;

        if (config.*field < min.*field)
          config.*field = min.*field;
      }

      virtual void calcLevel(uint32_t &comb_level, const PFDriverR2300Config &config1, const PFDriverR2300Config &config2) const override
      {
        if (config1.*field != config2.*field)
          comb_level |= level;
      }

      virtual void fromServer(const ros::NodeHandle &nh, PFDriverR2300Config &config) const override
      {
        nh.getParam(name, config.*field);
      }

      virtual void toServer(const ros::NodeHandle &nh, const PFDriverR2300Config &config) const override
      {
        nh.setParam(name, config.*field);
      }

      virtual bool fromMessage(const dynamic_reconfigure::Config &msg, PFDriverR2300Config &config) const override
      {
        return dynamic_reconfigure::ConfigTools::getParameter(msg, name, config.*field);
      }

      virtual void toMessage(dynamic_reconfigure::Config &msg, const PFDriverR2300Config &config) const override
      {
        dynamic_reconfigure::ConfigTools::appendParameter(msg, name, config.*field);
      }

      virtual void getValue(const PFDriverR2300Config &config, boost::any &val) const override
      {
        val = config.*field;
      }
    };

    class AbstractGroupDescription : public dynamic_reconfigure::Group
    {
      public:
      AbstractGroupDescription(std::string n, std::string t, int p, int i, bool s)
      {
        name = n;
        type = t;
        parent = p;
        state = s;
        id = i;
      }

      virtual ~AbstractGroupDescription() = default;

      std::vector<AbstractParamDescriptionConstPtr> abstract_parameters;
      bool state;

      virtual void toMessage(dynamic_reconfigure::Config &msg, const boost::any &config) const = 0;
      virtual bool fromMessage(const dynamic_reconfigure::Config &msg, boost::any &config) const =0;
      virtual void updateParams(boost::any &cfg, PFDriverR2300Config &top) const= 0;
      virtual void setInitialState(boost::any &cfg) const = 0;


      void convertParams()
      {
        for(std::vector<AbstractParamDescriptionConstPtr>::const_iterator i = abstract_parameters.begin(); i != abstract_parameters.end(); ++i)
        {
          parameters.push_back(dynamic_reconfigure::ParamDescription(**i));
        }
      }
    };

    typedef boost::shared_ptr<AbstractGroupDescription> AbstractGroupDescriptionPtr;
    typedef boost::shared_ptr<const AbstractGroupDescription> AbstractGroupDescriptionConstPtr;

    // Final keyword added to class because it has virtual methods and inherits
    // from a class with a non-virtual destructor.
    template<class T, class PT>
    class GroupDescription DYNAMIC_RECONFIGURE_FINAL : public AbstractGroupDescription
    {
    public:
      GroupDescription(std::string a_name, std::string a_type, int a_parent, int a_id, bool a_s, T PT::* a_f) : AbstractGroupDescription(a_name, a_type, a_parent, a_id, a_s), field(a_f)
      {
      }

      GroupDescription(const GroupDescription<T, PT>& g): AbstractGroupDescription(g.name, g.type, g.parent, g.id, g.state), field(g.field), groups(g.groups)
      {
        parameters = g.parameters;
        abstract_parameters = g.abstract_parameters;
      }

      virtual bool fromMessage(const dynamic_reconfigure::Config &msg, boost::any &cfg) const override
      {
        PT* config = boost::any_cast<PT*>(cfg);
        if(!dynamic_reconfigure::ConfigTools::getGroupState(msg, name, (*config).*field))
          return false;

        for(std::vector<AbstractGroupDescriptionConstPtr>::const_iterator i = groups.begin(); i != groups.end(); ++i)
        {
          boost::any n = &((*config).*field);
          if(!(*i)->fromMessage(msg, n))
            return false;
        }

        return true;
      }

      virtual void setInitialState(boost::any &cfg) const override
      {
        PT* config = boost::any_cast<PT*>(cfg);
        T* group = &((*config).*field);
        group->state = state;

        for(std::vector<AbstractGroupDescriptionConstPtr>::const_iterator i = groups.begin(); i != groups.end(); ++i)
        {
          boost::any n = boost::any(&((*config).*field));
          (*i)->setInitialState(n);
        }

      }

      virtual void updateParams(boost::any &cfg, PFDriverR2300Config &top) const override
      {
        PT* config = boost::any_cast<PT*>(cfg);

        T* f = &((*config).*field);
        f->setParams(top, abstract_parameters);

        for(std::vector<AbstractGroupDescriptionConstPtr>::const_iterator i = groups.begin(); i != groups.end(); ++i)
        {
          boost::any n = &((*config).*field);
          (*i)->updateParams(n, top);
        }
      }

      virtual void toMessage(dynamic_reconfigure::Config &msg, const boost::any &cfg) const override
      {
        const PT config = boost::any_cast<PT>(cfg);
        dynamic_reconfigure::ConfigTools::appendGroup<T>(msg, name, id, parent, config.*field);

        for(std::vector<AbstractGroupDescriptionConstPtr>::const_iterator i = groups.begin(); i != groups.end(); ++i)
        {
          (*i)->toMessage(msg, config.*field);
        }
      }

      T PT::* field;
      std::vector<PFDriverR2300Config::AbstractGroupDescriptionConstPtr> groups;
    };

class DEFAULT
{
  public:
    DEFAULT()
    {
      state = true;
      name = "Default";
    }

    void setParams(PFDriverR2300Config &config, const std::vector<AbstractParamDescriptionConstPtr> params)
    {
      for (std::vector<AbstractParamDescriptionConstPtr>::const_iterator _i = params.begin(); _i != params.end(); ++_i)
      {
        boost::any val;
        (*_i)->getValue(config, val);

        if("ip_mode"==(*_i)->name){ip_mode = boost::any_cast<std::string>(val);}
        if("ip_address"==(*_i)->name){ip_address = boost::any_cast<std::string>(val);}
        if("subnet_mask"==(*_i)->name){subnet_mask = boost::any_cast<std::string>(val);}
        if("gateway"==(*_i)->name){gateway = boost::any_cast<std::string>(val);}
        if("user_tag"==(*_i)->name){user_tag = boost::any_cast<std::string>(val);}
        if("layer_enable"==(*_i)->name){layer_enable = boost::any_cast<std::string>(val);}
        if("scan_frequency"==(*_i)->name){scan_frequency = boost::any_cast<int>(val);}
        if("scan_direction"==(*_i)->name){scan_direction = boost::any_cast<std::string>(val);}
        if("measure_start_angle"==(*_i)->name){measure_start_angle = boost::any_cast<double>(val);}
        if("measure_stop_angle"==(*_i)->name){measure_stop_angle = boost::any_cast<double>(val);}
        if("locator_indication"==(*_i)->name){locator_indication = boost::any_cast<std::string>(val);}
        if("pilot_laser"==(*_i)->name){pilot_laser = boost::any_cast<std::string>(val);}
        if("pilot_start_angle"==(*_i)->name){pilot_start_angle = boost::any_cast<double>(val);}
        if("pilot_stop_angle"==(*_i)->name){pilot_stop_angle = boost::any_cast<double>(val);}
        if("operating_mode"==(*_i)->name){operating_mode = boost::any_cast<std::string>(val);}
        if("address"==(*_i)->name){address = boost::any_cast<std::string>(val);}
        if("port"==(*_i)->name){port = boost::any_cast<int>(val);}
        if("packet_type"==(*_i)->name){packet_type = boost::any_cast<std::string>(val);}
        if("packet_crc"==(*_i)->name){packet_crc = boost::any_cast<std::string>(val);}
        if("watchdog"==(*_i)->name){watchdog = boost::any_cast<std::string>(val);}
        if("watchdogtimeout"==(*_i)->name){watchdogtimeout = boost::any_cast<int>(val);}
        if("start_angle"==(*_i)->name){start_angle = boost::any_cast<double>(val);}
        if("max_num_points_scan"==(*_i)->name){max_num_points_scan = boost::any_cast<int>(val);}
        if("skip_scans"==(*_i)->name){skip_scans = boost::any_cast<int>(val);}
      }
    }

    std::string ip_mode;
std::string ip_address;
std::string subnet_mask;
std::string gateway;
std::string user_tag;
std::string layer_enable;
int scan_frequency;
std::string scan_direction;
double measure_start_angle;
double measure_stop_angle;
std::string locator_indication;
std::string pilot_laser;
double pilot_start_angle;
double pilot_stop_angle;
std::string operating_mode;
std::string address;
int port;
std::string packet_type;
std::string packet_crc;
std::string watchdog;
int watchdogtimeout;
double start_angle;
int max_num_points_scan;
int skip_scans;

    bool state;
    std::string name;

    
}groups;



//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      std::string ip_mode;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      std::string ip_address;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      std::string subnet_mask;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      std::string gateway;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      std::string user_tag;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      std::string layer_enable;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      int scan_frequency;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      std::string scan_direction;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      double measure_start_angle;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      double measure_stop_angle;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      std::string locator_indication;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      std::string pilot_laser;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      double pilot_start_angle;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      double pilot_stop_angle;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      std::string operating_mode;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      std::string address;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      int port;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      std::string packet_type;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      std::string packet_crc;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      std::string watchdog;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      int watchdogtimeout;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      double start_angle;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      int max_num_points_scan;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      int skip_scans;
//#line 231 "/opt/ros/noetic/share/dynamic_reconfigure/cmake/../templates/ConfigType.h.template"

    bool __fromMessage__(dynamic_reconfigure::Config &msg)
    {
      const std::vector<AbstractParamDescriptionConstPtr> &__param_descriptions__ = __getParamDescriptions__();
      const std::vector<AbstractGroupDescriptionConstPtr> &__group_descriptions__ = __getGroupDescriptions__();

      int count = 0;
      for (std::vector<AbstractParamDescriptionConstPtr>::const_iterator i = __param_descriptions__.begin(); i != __param_descriptions__.end(); ++i)
        if ((*i)->fromMessage(msg, *this))
          count++;

      for (std::vector<AbstractGroupDescriptionConstPtr>::const_iterator i = __group_descriptions__.begin(); i != __group_descriptions__.end(); i ++)
      {
        if ((*i)->id == 0)
        {
          boost::any n = boost::any(this);
          (*i)->updateParams(n, *this);
          (*i)->fromMessage(msg, n);
        }
      }

      if (count != dynamic_reconfigure::ConfigTools::size(msg))
      {
        ROS_ERROR("PFDriverR2300Config::__fromMessage__ called with an unexpected parameter.");
        ROS_ERROR("Booleans:");
        for (unsigned int i = 0; i < msg.bools.size(); i++)
          ROS_ERROR("  %s", msg.bools[i].name.c_str());
        ROS_ERROR("Integers:");
        for (unsigned int i = 0; i < msg.ints.size(); i++)
          ROS_ERROR("  %s", msg.ints[i].name.c_str());
        ROS_ERROR("Doubles:");
        for (unsigned int i = 0; i < msg.doubles.size(); i++)
          ROS_ERROR("  %s", msg.doubles[i].name.c_str());
        ROS_ERROR("Strings:");
        for (unsigned int i = 0; i < msg.strs.size(); i++)
          ROS_ERROR("  %s", msg.strs[i].name.c_str());
        // @todo Check that there are no duplicates. Make this error more
        // explicit.
        return false;
      }
      return true;
    }

    // This version of __toMessage__ is used during initialization of
    // statics when __getParamDescriptions__ can't be called yet.
    void __toMessage__(dynamic_reconfigure::Config &msg, const std::vector<AbstractParamDescriptionConstPtr> &__param_descriptions__, const std::vector<AbstractGroupDescriptionConstPtr> &__group_descriptions__) const
    {
      dynamic_reconfigure::ConfigTools::clear(msg);
      for (std::vector<AbstractParamDescriptionConstPtr>::const_iterator i = __param_descriptions__.begin(); i != __param_descriptions__.end(); ++i)
        (*i)->toMessage(msg, *this);

      for (std::vector<AbstractGroupDescriptionConstPtr>::const_iterator i = __group_descriptions__.begin(); i != __group_descriptions__.end(); ++i)
      {
        if((*i)->id == 0)
        {
          (*i)->toMessage(msg, *this);
        }
      }
    }

    void __toMessage__(dynamic_reconfigure::Config &msg) const
    {
      const std::vector<AbstractParamDescriptionConstPtr> &__param_descriptions__ = __getParamDescriptions__();
      const std::vector<AbstractGroupDescriptionConstPtr> &__group_descriptions__ = __getGroupDescriptions__();
      __toMessage__(msg, __param_descriptions__, __group_descriptions__);
    }

    void __toServer__(const ros::NodeHandle &nh) const
    {
      const std::vector<AbstractParamDescriptionConstPtr> &__param_descriptions__ = __getParamDescriptions__();
      for (std::vector<AbstractParamDescriptionConstPtr>::const_iterator i = __param_descriptions__.begin(); i != __param_descriptions__.end(); ++i)
        (*i)->toServer(nh, *this);
    }

    void __fromServer__(const ros::NodeHandle &nh)
    {
      static bool setup=false;

      const std::vector<AbstractParamDescriptionConstPtr> &__param_descriptions__ = __getParamDescriptions__();
      for (std::vector<AbstractParamDescriptionConstPtr>::const_iterator i = __param_descriptions__.begin(); i != __param_descriptions__.end(); ++i)
        (*i)->fromServer(nh, *this);

      const std::vector<AbstractGroupDescriptionConstPtr> &__group_descriptions__ = __getGroupDescriptions__();
      for (std::vector<AbstractGroupDescriptionConstPtr>::const_iterator i = __group_descriptions__.begin(); i != __group_descriptions__.end(); i++){
        if (!setup && (*i)->id == 0) {
          setup = true;
          boost::any n = boost::any(this);
          (*i)->setInitialState(n);
        }
      }
    }

    void __clamp__()
    {
      const std::vector<AbstractParamDescriptionConstPtr> &__param_descriptions__ = __getParamDescriptions__();
      const PFDriverR2300Config &__max__ = __getMax__();
      const PFDriverR2300Config &__min__ = __getMin__();
      for (std::vector<AbstractParamDescriptionConstPtr>::const_iterator i = __param_descriptions__.begin(); i != __param_descriptions__.end(); ++i)
        (*i)->clamp(*this, __max__, __min__);
    }

    uint32_t __level__(const PFDriverR2300Config &config) const
    {
      const std::vector<AbstractParamDescriptionConstPtr> &__param_descriptions__ = __getParamDescriptions__();
      uint32_t level = 0;
      for (std::vector<AbstractParamDescriptionConstPtr>::const_iterator i = __param_descriptions__.begin(); i != __param_descriptions__.end(); ++i)
        (*i)->calcLevel(level, config, *this);
      return level;
    }

    static const dynamic_reconfigure::ConfigDescription &__getDescriptionMessage__();
    static const PFDriverR2300Config &__getDefault__();
    static const PFDriverR2300Config &__getMax__();
    static const PFDriverR2300Config &__getMin__();
    static const std::vector<AbstractParamDescriptionConstPtr> &__getParamDescriptions__();
    static const std::vector<AbstractGroupDescriptionConstPtr> &__getGroupDescriptions__();

  private:
    static const PFDriverR2300ConfigStatics *__get_statics__();
  };

  template <> // Max and min are ignored for strings.
  inline void PFDriverR2300Config::ParamDescription<std::string>::clamp(PFDriverR2300Config &config, const PFDriverR2300Config &max, const PFDriverR2300Config &min) const
  {
    (void) config;
    (void) min;
    (void) max;
    return;
  }

  class PFDriverR2300ConfigStatics
  {
    friend class PFDriverR2300Config;

    PFDriverR2300ConfigStatics()
    {
PFDriverR2300Config::GroupDescription<PFDriverR2300Config::DEFAULT, PFDriverR2300Config> Default("Default", "", 0, 0, true, &PFDriverR2300Config::groups);
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __min__.ip_mode = "";
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __max__.ip_mode = "";
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __default__.ip_mode = "autoip";
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      Default.abstract_parameters.push_back(PFDriverR2300Config::AbstractParamDescriptionConstPtr(new PFDriverR2300Config::ParamDescription<std::string>("ip_mode", "str", 1, "ip_mode value determines the method used by the device to determine its own IP and network conﬁguration.", "{'enum': [{'name': 'static', 'type': 'str', 'value': 'static', 'srcline': 11, 'srcfile': '/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2300.cfg', 'description': 'Static IP mode', 'ctype': 'std::string', 'cconsttype': 'const char * const'}, {'name': 'dhcp', 'type': 'str', 'value': 'dhcp', 'srcline': 12, 'srcfile': '/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2300.cfg', 'description': 'DHCP IP mode', 'ctype': 'std::string', 'cconsttype': 'const char * const'}, {'name': 'autoip', 'type': 'str', 'value': 'autoip', 'srcline': 13, 'srcfile': '/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2300.cfg', 'description': 'AutoIP mode', 'ctype': 'std::string', 'cconsttype': 'const char * const'}], 'enum_description': 'An enum to set IP mode'}", &PFDriverR2300Config::ip_mode)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __param_descriptions__.push_back(PFDriverR2300Config::AbstractParamDescriptionConstPtr(new PFDriverR2300Config::ParamDescription<std::string>("ip_mode", "str", 1, "ip_mode value determines the method used by the device to determine its own IP and network conﬁguration.", "{'enum': [{'name': 'static', 'type': 'str', 'value': 'static', 'srcline': 11, 'srcfile': '/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2300.cfg', 'description': 'Static IP mode', 'ctype': 'std::string', 'cconsttype': 'const char * const'}, {'name': 'dhcp', 'type': 'str', 'value': 'dhcp', 'srcline': 12, 'srcfile': '/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2300.cfg', 'description': 'DHCP IP mode', 'ctype': 'std::string', 'cconsttype': 'const char * const'}, {'name': 'autoip', 'type': 'str', 'value': 'autoip', 'srcline': 13, 'srcfile': '/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2300.cfg', 'description': 'AutoIP mode', 'ctype': 'std::string', 'cconsttype': 'const char * const'}], 'enum_description': 'An enum to set IP mode'}", &PFDriverR2300Config::ip_mode)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __min__.ip_address = "";
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __max__.ip_address = "";
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __default__.ip_address = "10.0.10.76";
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      Default.abstract_parameters.push_back(PFDriverR2300Config::AbstractParamDescriptionConstPtr(new PFDriverR2300Config::ParamDescription<std::string>("ip_address", "str", 2, "IP address", "", &PFDriverR2300Config::ip_address)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __param_descriptions__.push_back(PFDriverR2300Config::AbstractParamDescriptionConstPtr(new PFDriverR2300Config::ParamDescription<std::string>("ip_address", "str", 2, "IP address", "", &PFDriverR2300Config::ip_address)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __min__.subnet_mask = "";
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __max__.subnet_mask = "";
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __default__.subnet_mask = "255.0.0.0";
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      Default.abstract_parameters.push_back(PFDriverR2300Config::AbstractParamDescriptionConstPtr(new PFDriverR2300Config::ParamDescription<std::string>("subnet_mask", "str", 3, "IP netmask", "", &PFDriverR2300Config::subnet_mask)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __param_descriptions__.push_back(PFDriverR2300Config::AbstractParamDescriptionConstPtr(new PFDriverR2300Config::ParamDescription<std::string>("subnet_mask", "str", 3, "IP netmask", "", &PFDriverR2300Config::subnet_mask)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __min__.gateway = "";
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __max__.gateway = "";
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __default__.gateway = "0.0.0.0";
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      Default.abstract_parameters.push_back(PFDriverR2300Config::AbstractParamDescriptionConstPtr(new PFDriverR2300Config::ParamDescription<std::string>("gateway", "str", 4, "IP gateway", "", &PFDriverR2300Config::gateway)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __param_descriptions__.push_back(PFDriverR2300Config::AbstractParamDescriptionConstPtr(new PFDriverR2300Config::ParamDescription<std::string>("gateway", "str", 4, "IP gateway", "", &PFDriverR2300Config::gateway)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __min__.user_tag = "";
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __max__.user_tag = "";
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __default__.user_tag = "OMD10M-R2300";
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      Default.abstract_parameters.push_back(PFDriverR2300Config::AbstractParamDescriptionConstPtr(new PFDriverR2300Config::ParamDescription<std::string>("user_tag", "str", 5, "Short UTF8 string for user purposes, up to 32 bytes not chars! (32 chars on R2000)", "", &PFDriverR2300Config::user_tag)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __param_descriptions__.push_back(PFDriverR2300Config::AbstractParamDescriptionConstPtr(new PFDriverR2300Config::ParamDescription<std::string>("user_tag", "str", 5, "Short UTF8 string for user purposes, up to 32 bytes not chars! (32 chars on R2000)", "", &PFDriverR2300Config::user_tag)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __min__.layer_enable = "";
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __max__.layer_enable = "";
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __default__.layer_enable = "on,on,on,on";
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      Default.abstract_parameters.push_back(PFDriverR2300Config::AbstractParamDescriptionConstPtr(new PFDriverR2300Config::ParamDescription<std::string>("layer_enable", "str", 6, "An on or off value for each of the layers indexed 0..3 determines whether measurement takes place in that layer. When setting, specify the values as comma-separated list.", "{'enum': [{'name': 'on_on_on_on', 'type': 'str', 'value': 'on,on,on,on', 'srcline': 21, 'srcfile': '/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2300.cfg', 'description': '', 'ctype': 'std::string', 'cconsttype': 'const char * const'}, {'name': 'on_on_on_off', 'type': 'str', 'value': 'on,on,on,off', 'srcline': 22, 'srcfile': '/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2300.cfg', 'description': '', 'ctype': 'std::string', 'cconsttype': 'const char * const'}, {'name': 'on_on_off_on', 'type': 'str', 'value': 'on,on,off,on', 'srcline': 23, 'srcfile': '/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2300.cfg', 'description': '', 'ctype': 'std::string', 'cconsttype': 'const char * const'}, {'name': 'on_on_off_off', 'type': 'str', 'value': 'on,on,off,off', 'srcline': 24, 'srcfile': '/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2300.cfg', 'description': '', 'ctype': 'std::string', 'cconsttype': 'const char * const'}, {'name': 'on_off_on_on', 'type': 'str', 'value': 'on,off,on,on', 'srcline': 25, 'srcfile': '/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2300.cfg', 'description': '', 'ctype': 'std::string', 'cconsttype': 'const char * const'}, {'name': 'on_off_on_off', 'type': 'str', 'value': 'on,off,on,off', 'srcline': 26, 'srcfile': '/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2300.cfg', 'description': '', 'ctype': 'std::string', 'cconsttype': 'const char * const'}, {'name': 'on_off_off_on', 'type': 'str', 'value': 'on,off,off,on', 'srcline': 27, 'srcfile': '/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2300.cfg', 'description': '', 'ctype': 'std::string', 'cconsttype': 'const char * const'}, {'name': 'on_off_off_off', 'type': 'str', 'value': 'on,off,off,off', 'srcline': 28, 'srcfile': '/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2300.cfg', 'description': '', 'ctype': 'std::string', 'cconsttype': 'const char * const'}, {'name': 'off_on_on_on', 'type': 'str', 'value': 'off,on,on,on', 'srcline': 29, 'srcfile': '/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2300.cfg', 'description': '', 'ctype': 'std::string', 'cconsttype': 'const char * const'}, {'name': 'off_on_on_off', 'type': 'str', 'value': 'off,on,on,off', 'srcline': 30, 'srcfile': '/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2300.cfg', 'description': '', 'ctype': 'std::string', 'cconsttype': 'const char * const'}, {'name': 'off_on_off_on', 'type': 'str', 'value': 'off,on,off,on', 'srcline': 31, 'srcfile': '/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2300.cfg', 'description': '', 'ctype': 'std::string', 'cconsttype': 'const char * const'}, {'name': 'off_on_off_off', 'type': 'str', 'value': 'off,on,off,off', 'srcline': 32, 'srcfile': '/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2300.cfg', 'description': '', 'ctype': 'std::string', 'cconsttype': 'const char * const'}, {'name': 'off_off_on_on', 'type': 'str', 'value': 'off,off,on,on', 'srcline': 33, 'srcfile': '/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2300.cfg', 'description': '', 'ctype': 'std::string', 'cconsttype': 'const char * const'}, {'name': 'off_off_on_off', 'type': 'str', 'value': 'off,off,on,off', 'srcline': 34, 'srcfile': '/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2300.cfg', 'description': '', 'ctype': 'std::string', 'cconsttype': 'const char * const'}, {'name': 'off_off_off_on', 'type': 'str', 'value': 'off,off,off,on', 'srcline': 35, 'srcfile': '/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2300.cfg', 'description': '', 'ctype': 'std::string', 'cconsttype': 'const char * const'}, {'name': 'off_off_off_off', 'type': 'str', 'value': 'off,off,off,off', 'srcline': 36, 'srcfile': '/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2300.cfg', 'description': '', 'ctype': 'std::string', 'cconsttype': 'const char * const'}], 'enum_description': 'An enum to set layers'}", &PFDriverR2300Config::layer_enable)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __param_descriptions__.push_back(PFDriverR2300Config::AbstractParamDescriptionConstPtr(new PFDriverR2300Config::ParamDescription<std::string>("layer_enable", "str", 6, "An on or off value for each of the layers indexed 0..3 determines whether measurement takes place in that layer. When setting, specify the values as comma-separated list.", "{'enum': [{'name': 'on_on_on_on', 'type': 'str', 'value': 'on,on,on,on', 'srcline': 21, 'srcfile': '/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2300.cfg', 'description': '', 'ctype': 'std::string', 'cconsttype': 'const char * const'}, {'name': 'on_on_on_off', 'type': 'str', 'value': 'on,on,on,off', 'srcline': 22, 'srcfile': '/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2300.cfg', 'description': '', 'ctype': 'std::string', 'cconsttype': 'const char * const'}, {'name': 'on_on_off_on', 'type': 'str', 'value': 'on,on,off,on', 'srcline': 23, 'srcfile': '/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2300.cfg', 'description': '', 'ctype': 'std::string', 'cconsttype': 'const char * const'}, {'name': 'on_on_off_off', 'type': 'str', 'value': 'on,on,off,off', 'srcline': 24, 'srcfile': '/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2300.cfg', 'description': '', 'ctype': 'std::string', 'cconsttype': 'const char * const'}, {'name': 'on_off_on_on', 'type': 'str', 'value': 'on,off,on,on', 'srcline': 25, 'srcfile': '/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2300.cfg', 'description': '', 'ctype': 'std::string', 'cconsttype': 'const char * const'}, {'name': 'on_off_on_off', 'type': 'str', 'value': 'on,off,on,off', 'srcline': 26, 'srcfile': '/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2300.cfg', 'description': '', 'ctype': 'std::string', 'cconsttype': 'const char * const'}, {'name': 'on_off_off_on', 'type': 'str', 'value': 'on,off,off,on', 'srcline': 27, 'srcfile': '/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2300.cfg', 'description': '', 'ctype': 'std::string', 'cconsttype': 'const char * const'}, {'name': 'on_off_off_off', 'type': 'str', 'value': 'on,off,off,off', 'srcline': 28, 'srcfile': '/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2300.cfg', 'description': '', 'ctype': 'std::string', 'cconsttype': 'const char * const'}, {'name': 'off_on_on_on', 'type': 'str', 'value': 'off,on,on,on', 'srcline': 29, 'srcfile': '/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2300.cfg', 'description': '', 'ctype': 'std::string', 'cconsttype': 'const char * const'}, {'name': 'off_on_on_off', 'type': 'str', 'value': 'off,on,on,off', 'srcline': 30, 'srcfile': '/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2300.cfg', 'description': '', 'ctype': 'std::string', 'cconsttype': 'const char * const'}, {'name': 'off_on_off_on', 'type': 'str', 'value': 'off,on,off,on', 'srcline': 31, 'srcfile': '/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2300.cfg', 'description': '', 'ctype': 'std::string', 'cconsttype': 'const char * const'}, {'name': 'off_on_off_off', 'type': 'str', 'value': 'off,on,off,off', 'srcline': 32, 'srcfile': '/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2300.cfg', 'description': '', 'ctype': 'std::string', 'cconsttype': 'const char * const'}, {'name': 'off_off_on_on', 'type': 'str', 'value': 'off,off,on,on', 'srcline': 33, 'srcfile': '/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2300.cfg', 'description': '', 'ctype': 'std::string', 'cconsttype': 'const char * const'}, {'name': 'off_off_on_off', 'type': 'str', 'value': 'off,off,on,off', 'srcline': 34, 'srcfile': '/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2300.cfg', 'description': '', 'ctype': 'std::string', 'cconsttype': 'const char * const'}, {'name': 'off_off_off_on', 'type': 'str', 'value': 'off,off,off,on', 'srcline': 35, 'srcfile': '/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2300.cfg', 'description': '', 'ctype': 'std::string', 'cconsttype': 'const char * const'}, {'name': 'off_off_off_off', 'type': 'str', 'value': 'off,off,off,off', 'srcline': 36, 'srcfile': '/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2300.cfg', 'description': '', 'ctype': 'std::string', 'cconsttype': 'const char * const'}], 'enum_description': 'An enum to set layers'}", &PFDriverR2300Config::layer_enable)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __min__.scan_frequency = -2147483648;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __max__.scan_frequency = 2147483647;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __default__.scan_frequency = 100;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      Default.abstract_parameters.push_back(PFDriverR2300Config::AbstractParamDescriptionConstPtr(new PFDriverR2300Config::ParamDescription<int>("scan_frequency", "int", 7, "The scan_frequency determines the number of scans taken per second. A scan means a contiguous set of measurements taken within range measure_start_angle to measure_stop_angle. Changing the scan_frequency to either 50 or 100 Hz as a side effect also determines the angular resolution: 0.1° at 50 Hz or 0.2° at 100 Hz.", "", &PFDriverR2300Config::scan_frequency)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __param_descriptions__.push_back(PFDriverR2300Config::AbstractParamDescriptionConstPtr(new PFDriverR2300Config::ParamDescription<int>("scan_frequency", "int", 7, "The scan_frequency determines the number of scans taken per second. A scan means a contiguous set of measurements taken within range measure_start_angle to measure_stop_angle. Changing the scan_frequency to either 50 or 100 Hz as a side effect also determines the angular resolution: 0.1° at 50 Hz or 0.2° at 100 Hz.", "", &PFDriverR2300Config::scan_frequency)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __min__.scan_direction = "";
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __max__.scan_direction = "";
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __default__.scan_direction = "ccw";
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      Default.abstract_parameters.push_back(PFDriverR2300Config::AbstractParamDescriptionConstPtr(new PFDriverR2300Config::ParamDescription<std::string>("scan_direction", "str", 8, "The scan_direction may allow to change the direction of scanning and therefore also the order of the measurements (direction of ﬁrst measurement) in time. Currently, the setting is ﬁxed to 'ccw' (counter-clockwise, mathematically positive), and 'cw' (clockwise) is not really supported.", "", &PFDriverR2300Config::scan_direction)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __param_descriptions__.push_back(PFDriverR2300Config::AbstractParamDescriptionConstPtr(new PFDriverR2300Config::ParamDescription<std::string>("scan_direction", "str", 8, "The scan_direction may allow to change the direction of scanning and therefore also the order of the measurements (direction of ﬁrst measurement) in time. Currently, the setting is ﬁxed to 'ccw' (counter-clockwise, mathematically positive), and 'cw' (clockwise) is not really supported.", "", &PFDriverR2300Config::scan_direction)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __min__.measure_start_angle = -500000.0;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __max__.measure_start_angle = 500000.0;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __default__.measure_start_angle = -500000.0;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      Default.abstract_parameters.push_back(PFDriverR2300Config::AbstractParamDescriptionConstPtr(new PFDriverR2300Config::ParamDescription<double>("measure_start_angle", "double", 9, "measure_start_angle (unit: 1/10000 degree) limits the scanning range at one end, while measure_stop_angle determines the other end limit. Scans consist of all samples exactly at and between those two limits, taken at angles rounded to multiples of the current angular resolution as determined by scan_frequency. This is a persistent setting, kept in persistent memory. For dynamic selection of measurement range without wearing out parameter memory, it is recommended to utilize the Scan output options start_angle and max_num_points_scan instead.", "", &PFDriverR2300Config::measure_start_angle)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __param_descriptions__.push_back(PFDriverR2300Config::AbstractParamDescriptionConstPtr(new PFDriverR2300Config::ParamDescription<double>("measure_start_angle", "double", 9, "measure_start_angle (unit: 1/10000 degree) limits the scanning range at one end, while measure_stop_angle determines the other end limit. Scans consist of all samples exactly at and between those two limits, taken at angles rounded to multiples of the current angular resolution as determined by scan_frequency. This is a persistent setting, kept in persistent memory. For dynamic selection of measurement range without wearing out parameter memory, it is recommended to utilize the Scan output options start_angle and max_num_points_scan instead.", "", &PFDriverR2300Config::measure_start_angle)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __min__.measure_stop_angle = -500000.0;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __max__.measure_stop_angle = 500000.0;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __default__.measure_stop_angle = 500000.0;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      Default.abstract_parameters.push_back(PFDriverR2300Config::AbstractParamDescriptionConstPtr(new PFDriverR2300Config::ParamDescription<double>("measure_stop_angle", "double", 10, "See measure_start_angle for description", "", &PFDriverR2300Config::measure_stop_angle)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __param_descriptions__.push_back(PFDriverR2300Config::AbstractParamDescriptionConstPtr(new PFDriverR2300Config::ParamDescription<double>("measure_stop_angle", "double", 10, "See measure_start_angle for description", "", &PFDriverR2300Config::measure_stop_angle)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __min__.locator_indication = "";
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __max__.locator_indication = "";
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __default__.locator_indication = "off";
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      Default.abstract_parameters.push_back(PFDriverR2300Config::AbstractParamDescriptionConstPtr(new PFDriverR2300Config::ParamDescription<std::string>("locator_indication", "str", 11, "Enable locator indication (on/off)", "{'enum': [{'name': 'locator_on', 'type': 'str', 'value': 'on', 'srcline': 44, 'srcfile': '/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2300.cfg', 'description': '', 'ctype': 'std::string', 'cconsttype': 'const char * const'}, {'name': 'locator_off', 'type': 'str', 'value': 'off', 'srcline': 45, 'srcfile': '/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2300.cfg', 'description': '', 'ctype': 'std::string', 'cconsttype': 'const char * const'}], 'enum_description': 'An enum to set locator indicator'}", &PFDriverR2300Config::locator_indication)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __param_descriptions__.push_back(PFDriverR2300Config::AbstractParamDescriptionConstPtr(new PFDriverR2300Config::ParamDescription<std::string>("locator_indication", "str", 11, "Enable locator indication (on/off)", "{'enum': [{'name': 'locator_on', 'type': 'str', 'value': 'on', 'srcline': 44, 'srcfile': '/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2300.cfg', 'description': '', 'ctype': 'std::string', 'cconsttype': 'const char * const'}, {'name': 'locator_off', 'type': 'str', 'value': 'off', 'srcline': 45, 'srcfile': '/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2300.cfg', 'description': '', 'ctype': 'std::string', 'cconsttype': 'const char * const'}], 'enum_description': 'An enum to set locator indicator'}", &PFDriverR2300Config::locator_indication)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __min__.pilot_laser = "";
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __max__.pilot_laser = "";
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __default__.pilot_laser = "off";
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      Default.abstract_parameters.push_back(PFDriverR2300Config::AbstractParamDescriptionConstPtr(new PFDriverR2300Config::ParamDescription<std::string>("pilot_laser", "str", 12, "General on or off switch for the red pilot laser. Its actual visibility (in current scanners) is further limited to the range in which measurement takes place, i.e. from measure_start_angle to measure_stop_angle, and also depends on the value of layer_enable.", "{'enum': [{'name': 'pilot_on', 'type': 'str', 'value': 'on', 'srcline': 49, 'srcfile': '/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2300.cfg', 'description': '', 'ctype': 'std::string', 'cconsttype': 'const char * const'}, {'name': 'pilot_off', 'type': 'str', 'value': 'off', 'srcline': 50, 'srcfile': '/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2300.cfg', 'description': '', 'ctype': 'std::string', 'cconsttype': 'const char * const'}], 'enum_description': 'An enum to set pilot laser'}", &PFDriverR2300Config::pilot_laser)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __param_descriptions__.push_back(PFDriverR2300Config::AbstractParamDescriptionConstPtr(new PFDriverR2300Config::ParamDescription<std::string>("pilot_laser", "str", 12, "General on or off switch for the red pilot laser. Its actual visibility (in current scanners) is further limited to the range in which measurement takes place, i.e. from measure_start_angle to measure_stop_angle, and also depends on the value of layer_enable.", "{'enum': [{'name': 'pilot_on', 'type': 'str', 'value': 'on', 'srcline': 49, 'srcfile': '/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2300.cfg', 'description': '', 'ctype': 'std::string', 'cconsttype': 'const char * const'}, {'name': 'pilot_off', 'type': 'str', 'value': 'off', 'srcline': 50, 'srcfile': '/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2300.cfg', 'description': '', 'ctype': 'std::string', 'cconsttype': 'const char * const'}], 'enum_description': 'An enum to set pilot laser'}", &PFDriverR2300Config::pilot_laser)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __min__.pilot_start_angle = -500000.0;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __max__.pilot_start_angle = 500000.0;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __default__.pilot_start_angle = -500000.0;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      Default.abstract_parameters.push_back(PFDriverR2300Config::AbstractParamDescriptionConstPtr(new PFDriverR2300Config::ParamDescription<double>("pilot_start_angle", "double", 13, "Angle where to enable red pilot laser", "", &PFDriverR2300Config::pilot_start_angle)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __param_descriptions__.push_back(PFDriverR2300Config::AbstractParamDescriptionConstPtr(new PFDriverR2300Config::ParamDescription<double>("pilot_start_angle", "double", 13, "Angle where to enable red pilot laser", "", &PFDriverR2300Config::pilot_start_angle)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __min__.pilot_stop_angle = -500000.0;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __max__.pilot_stop_angle = 500000.0;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __default__.pilot_stop_angle = 500000.0;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      Default.abstract_parameters.push_back(PFDriverR2300Config::AbstractParamDescriptionConstPtr(new PFDriverR2300Config::ParamDescription<double>("pilot_stop_angle", "double", 14, "Angle where to disable red pilot laser", "", &PFDriverR2300Config::pilot_stop_angle)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __param_descriptions__.push_back(PFDriverR2300Config::AbstractParamDescriptionConstPtr(new PFDriverR2300Config::ParamDescription<double>("pilot_stop_angle", "double", 14, "Angle where to disable red pilot laser", "", &PFDriverR2300Config::pilot_stop_angle)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __min__.operating_mode = "";
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __max__.operating_mode = "";
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __default__.operating_mode = "measure";
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      Default.abstract_parameters.push_back(PFDriverR2300Config::AbstractParamDescriptionConstPtr(new PFDriverR2300Config::ParamDescription<std::string>("operating_mode", "str", 15, "The operating_mode, always measure after power on, can be temporarily set to emitter_off to disable the laser pulse, e.g. in order to avoid affecting other scanners.", "{'enum': [{'name': 'measure', 'type': 'str', 'value': 'measure', 'srcline': 56, 'srcfile': '/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2300.cfg', 'description': 'measure mode', 'ctype': 'std::string', 'cconsttype': 'const char * const'}, {'name': 'emitter_off', 'type': 'str', 'value': 'emitter_off', 'srcline': 57, 'srcfile': '/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2300.cfg', 'description': 'emitter_off mode', 'ctype': 'std::string', 'cconsttype': 'const char * const'}], 'enum_description': 'An enum to set operating mode'}", &PFDriverR2300Config::operating_mode)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __param_descriptions__.push_back(PFDriverR2300Config::AbstractParamDescriptionConstPtr(new PFDriverR2300Config::ParamDescription<std::string>("operating_mode", "str", 15, "The operating_mode, always measure after power on, can be temporarily set to emitter_off to disable the laser pulse, e.g. in order to avoid affecting other scanners.", "{'enum': [{'name': 'measure', 'type': 'str', 'value': 'measure', 'srcline': 56, 'srcfile': '/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2300.cfg', 'description': 'measure mode', 'ctype': 'std::string', 'cconsttype': 'const char * const'}, {'name': 'emitter_off', 'type': 'str', 'value': 'emitter_off', 'srcline': 57, 'srcfile': '/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2300.cfg', 'description': 'emitter_off mode', 'ctype': 'std::string', 'cconsttype': 'const char * const'}], 'enum_description': 'An enum to set operating mode'}", &PFDriverR2300Config::operating_mode)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __min__.address = "";
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __max__.address = "";
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __default__.address = "";
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      Default.abstract_parameters.push_back(PFDriverR2300Config::AbstractParamDescriptionConstPtr(new PFDriverR2300Config::ParamDescription<std::string>("address", "str", 16, "When initiating scan data output, request_handle_udp must be given an IPv4 address and port in order to know where to send scandata to. The IPv4 typically should be the IP address of the host who also initiates the connection, e.g. 10.0.10.10, the port something like 6464.", "", &PFDriverR2300Config::address)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __param_descriptions__.push_back(PFDriverR2300Config::AbstractParamDescriptionConstPtr(new PFDriverR2300Config::ParamDescription<std::string>("address", "str", 16, "When initiating scan data output, request_handle_udp must be given an IPv4 address and port in order to know where to send scandata to. The IPv4 typically should be the IP address of the host who also initiates the connection, e.g. 10.0.10.10, the port something like 6464.", "", &PFDriverR2300Config::address)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __min__.port = -2147483648;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __max__.port = 2147483647;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __default__.port = 0;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      Default.abstract_parameters.push_back(PFDriverR2300Config::AbstractParamDescriptionConstPtr(new PFDriverR2300Config::ParamDescription<int>("port", "int", 17, "See address", "", &PFDriverR2300Config::port)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __param_descriptions__.push_back(PFDriverR2300Config::AbstractParamDescriptionConstPtr(new PFDriverR2300Config::ParamDescription<int>("port", "int", 17, "See address", "", &PFDriverR2300Config::port)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __min__.packet_type = "";
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __max__.packet_type = "";
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __default__.packet_type = "C1";
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      Default.abstract_parameters.push_back(PFDriverR2300Config::AbstractParamDescriptionConstPtr(new PFDriverR2300Config::ParamDescription<std::string>("packet_type", "str", 18, "Packet type for scan data output (always C1 on R2300)", "", &PFDriverR2300Config::packet_type)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __param_descriptions__.push_back(PFDriverR2300Config::AbstractParamDescriptionConstPtr(new PFDriverR2300Config::ParamDescription<std::string>("packet_type", "str", 18, "Packet type for scan data output (always C1 on R2300)", "", &PFDriverR2300Config::packet_type)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __min__.packet_crc = "";
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __max__.packet_crc = "";
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __default__.packet_crc = "";
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      Default.abstract_parameters.push_back(PFDriverR2300Config::AbstractParamDescriptionConstPtr(new PFDriverR2300Config::ParamDescription<std::string>("packet_crc", "str", 19, "Append extra CRC32 for scan data integrity check (currenty always none on R2300)", "", &PFDriverR2300Config::packet_crc)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __param_descriptions__.push_back(PFDriverR2300Config::AbstractParamDescriptionConstPtr(new PFDriverR2300Config::ParamDescription<std::string>("packet_crc", "str", 19, "Append extra CRC32 for scan data integrity check (currenty always none on R2300)", "", &PFDriverR2300Config::packet_crc)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __min__.watchdog = "";
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __max__.watchdog = "";
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __default__.watchdog = "off";
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      Default.abstract_parameters.push_back(PFDriverR2300Config::AbstractParamDescriptionConstPtr(new PFDriverR2300Config::ParamDescription<std::string>("watchdog", "str", 20, "Cease scan data output if watchdog isn't fed in time (always off on R2300)", "", &PFDriverR2300Config::watchdog)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __param_descriptions__.push_back(PFDriverR2300Config::AbstractParamDescriptionConstPtr(new PFDriverR2300Config::ParamDescription<std::string>("watchdog", "str", 20, "Cease scan data output if watchdog isn't fed in time (always off on R2300)", "", &PFDriverR2300Config::watchdog)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __min__.watchdogtimeout = -2147483648;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __max__.watchdogtimeout = 2147483647;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __default__.watchdogtimeout = 0;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      Default.abstract_parameters.push_back(PFDriverR2300Config::AbstractParamDescriptionConstPtr(new PFDriverR2300Config::ParamDescription<int>("watchdogtimeout", "int", 21, "Maximum time for client to feed watchdog", "", &PFDriverR2300Config::watchdogtimeout)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __param_descriptions__.push_back(PFDriverR2300Config::AbstractParamDescriptionConstPtr(new PFDriverR2300Config::ParamDescription<int>("watchdogtimeout", "int", 21, "Maximum time for client to feed watchdog", "", &PFDriverR2300Config::watchdogtimeout)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __min__.start_angle = -500000.0;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __max__.start_angle = std::numeric_limits<double>::infinity();
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __default__.start_angle = -500000.0;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      Default.abstract_parameters.push_back(PFDriverR2300Config::AbstractParamDescriptionConstPtr(new PFDriverR2300Config::ParamDescription<double>("start_angle", "double", 22, "Specifying a start_angle (in 1/10000 degree) allows to reduce the output of data. ∗ While device global settings measure_start_angle and measure_stop_angle determine the range where actual measurements (and laser pulses) take place, start_angle may be used to tell the scanner to include only a subset of the data (starting at or after start_angle) in the scan output. This is provided for compatibility with R2000, where more than one consumer might want different portions of the data, and so you don't have to dynamically update measure_start_angle continuously just to get another range output. The default is -1800000, which means all data.", "", &PFDriverR2300Config::start_angle)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __param_descriptions__.push_back(PFDriverR2300Config::AbstractParamDescriptionConstPtr(new PFDriverR2300Config::ParamDescription<double>("start_angle", "double", 22, "Specifying a start_angle (in 1/10000 degree) allows to reduce the output of data. ∗ While device global settings measure_start_angle and measure_stop_angle determine the range where actual measurements (and laser pulses) take place, start_angle may be used to tell the scanner to include only a subset of the data (starting at or after start_angle) in the scan output. This is provided for compatibility with R2000, where more than one consumer might want different portions of the data, and so you don't have to dynamically update measure_start_angle continuously just to get another range output. The default is -1800000, which means all data.", "", &PFDriverR2300Config::start_angle)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __min__.max_num_points_scan = 0;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __max__.max_num_points_scan = 2147483647;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __default__.max_num_points_scan = 0;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      Default.abstract_parameters.push_back(PFDriverR2300Config::AbstractParamDescriptionConstPtr(new PFDriverR2300Config::ParamDescription<int>("max_num_points_scan", "int", 23, "Specifying a max_num_points_scan (in 1/10000 degree) allows to reduce the output of data to the given number of measurements (or less if there are less in actual scan range). The default is 0, meaning all data. Note that the same number of measurements may cover double (or half) the angular range dependent on device global setting scan_frequency and thus angular resolution.", "", &PFDriverR2300Config::max_num_points_scan)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __param_descriptions__.push_back(PFDriverR2300Config::AbstractParamDescriptionConstPtr(new PFDriverR2300Config::ParamDescription<int>("max_num_points_scan", "int", 23, "Specifying a max_num_points_scan (in 1/10000 degree) allows to reduce the output of data to the given number of measurements (or less if there are less in actual scan range). The default is 0, meaning all data. Note that the same number of measurements may cover double (or half) the angular range dependent on device global setting scan_frequency and thus angular resolution.", "", &PFDriverR2300Config::max_num_points_scan)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __min__.skip_scans = 0;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __max__.skip_scans = 2147483647;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __default__.skip_scans = 0;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      Default.abstract_parameters.push_back(PFDriverR2300Config::AbstractParamDescriptionConstPtr(new PFDriverR2300Config::ParamDescription<int>("skip_scans", "int", 24, "Omit this number of scans (x layers) between output (always 0)", "", &PFDriverR2300Config::skip_scans)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __param_descriptions__.push_back(PFDriverR2300Config::AbstractParamDescriptionConstPtr(new PFDriverR2300Config::ParamDescription<int>("skip_scans", "int", 24, "Omit this number of scans (x layers) between output (always 0)", "", &PFDriverR2300Config::skip_scans)));
//#line 246 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      Default.convertParams();
//#line 246 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __group_descriptions__.push_back(PFDriverR2300Config::AbstractGroupDescriptionConstPtr(new PFDriverR2300Config::GroupDescription<PFDriverR2300Config::DEFAULT, PFDriverR2300Config>(Default)));
//#line 369 "/opt/ros/noetic/share/dynamic_reconfigure/cmake/../templates/ConfigType.h.template"

      for (std::vector<PFDriverR2300Config::AbstractGroupDescriptionConstPtr>::const_iterator i = __group_descriptions__.begin(); i != __group_descriptions__.end(); ++i)
      {
        __description_message__.groups.push_back(**i);
      }
      __max__.__toMessage__(__description_message__.max, __param_descriptions__, __group_descriptions__);
      __min__.__toMessage__(__description_message__.min, __param_descriptions__, __group_descriptions__);
      __default__.__toMessage__(__description_message__.dflt, __param_descriptions__, __group_descriptions__);
    }
    std::vector<PFDriverR2300Config::AbstractParamDescriptionConstPtr> __param_descriptions__;
    std::vector<PFDriverR2300Config::AbstractGroupDescriptionConstPtr> __group_descriptions__;
    PFDriverR2300Config __max__;
    PFDriverR2300Config __min__;
    PFDriverR2300Config __default__;
    dynamic_reconfigure::ConfigDescription __description_message__;

    static const PFDriverR2300ConfigStatics *get_instance()
    {
      // Split this off in a separate function because I know that
      // instance will get initialized the first time get_instance is
      // called, and I am guaranteeing that get_instance gets called at
      // most once.
      static PFDriverR2300ConfigStatics instance;
      return &instance;
    }
  };

  inline const dynamic_reconfigure::ConfigDescription &PFDriverR2300Config::__getDescriptionMessage__()
  {
    return __get_statics__()->__description_message__;
  }

  inline const PFDriverR2300Config &PFDriverR2300Config::__getDefault__()
  {
    return __get_statics__()->__default__;
  }

  inline const PFDriverR2300Config &PFDriverR2300Config::__getMax__()
  {
    return __get_statics__()->__max__;
  }

  inline const PFDriverR2300Config &PFDriverR2300Config::__getMin__()
  {
    return __get_statics__()->__min__;
  }

  inline const std::vector<PFDriverR2300Config::AbstractParamDescriptionConstPtr> &PFDriverR2300Config::__getParamDescriptions__()
  {
    return __get_statics__()->__param_descriptions__;
  }

  inline const std::vector<PFDriverR2300Config::AbstractGroupDescriptionConstPtr> &PFDriverR2300Config::__getGroupDescriptions__()
  {
    return __get_statics__()->__group_descriptions__;
  }

  inline const PFDriverR2300ConfigStatics *PFDriverR2300Config::__get_statics__()
  {
    const static PFDriverR2300ConfigStatics *statics;

    if (statics) // Common case
      return statics;

    boost::mutex::scoped_lock lock(dynamic_reconfigure::__init_mutex__);

    if (statics) // In case we lost a race.
      return statics;

    statics = PFDriverR2300ConfigStatics::get_instance();

    return statics;
  }

//#line 11 "/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2300.cfg"
      const char * const PFDriverR2300_static = "static";
//#line 12 "/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2300.cfg"
      const char * const PFDriverR2300_dhcp = "dhcp";
//#line 13 "/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2300.cfg"
      const char * const PFDriverR2300_autoip = "autoip";
//#line 21 "/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2300.cfg"
      const char * const PFDriverR2300_on_on_on_on = "on,on,on,on";
//#line 22 "/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2300.cfg"
      const char * const PFDriverR2300_on_on_on_off = "on,on,on,off";
//#line 23 "/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2300.cfg"
      const char * const PFDriverR2300_on_on_off_on = "on,on,off,on";
//#line 24 "/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2300.cfg"
      const char * const PFDriverR2300_on_on_off_off = "on,on,off,off";
//#line 25 "/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2300.cfg"
      const char * const PFDriverR2300_on_off_on_on = "on,off,on,on";
//#line 26 "/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2300.cfg"
      const char * const PFDriverR2300_on_off_on_off = "on,off,on,off";
//#line 27 "/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2300.cfg"
      const char * const PFDriverR2300_on_off_off_on = "on,off,off,on";
//#line 28 "/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2300.cfg"
      const char * const PFDriverR2300_on_off_off_off = "on,off,off,off";
//#line 29 "/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2300.cfg"
      const char * const PFDriverR2300_off_on_on_on = "off,on,on,on";
//#line 30 "/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2300.cfg"
      const char * const PFDriverR2300_off_on_on_off = "off,on,on,off";
//#line 31 "/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2300.cfg"
      const char * const PFDriverR2300_off_on_off_on = "off,on,off,on";
//#line 32 "/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2300.cfg"
      const char * const PFDriverR2300_off_on_off_off = "off,on,off,off";
//#line 33 "/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2300.cfg"
      const char * const PFDriverR2300_off_off_on_on = "off,off,on,on";
//#line 34 "/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2300.cfg"
      const char * const PFDriverR2300_off_off_on_off = "off,off,on,off";
//#line 35 "/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2300.cfg"
      const char * const PFDriverR2300_off_off_off_on = "off,off,off,on";
//#line 36 "/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2300.cfg"
      const char * const PFDriverR2300_off_off_off_off = "off,off,off,off";
//#line 44 "/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2300.cfg"
      const char * const PFDriverR2300_locator_on = "on";
//#line 45 "/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2300.cfg"
      const char * const PFDriverR2300_locator_off = "off";
//#line 49 "/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2300.cfg"
      const char * const PFDriverR2300_pilot_on = "on";
//#line 50 "/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2300.cfg"
      const char * const PFDriverR2300_pilot_off = "off";
//#line 56 "/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2300.cfg"
      const char * const PFDriverR2300_measure = "measure";
//#line 57 "/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2300.cfg"
      const char * const PFDriverR2300_emitter_off = "emitter_off";
}

#undef DYNAMIC_RECONFIGURE_FINAL

#endif // __PFDRIVERR2300RECONFIGURATOR_H__
