//#line 2 "/opt/ros/noetic/share/dynamic_reconfigure/cmake/../templates/ConfigType.h.template"
// *********************************************************
//
// File autogenerated for the pf_driver package
// by the dynamic_reconfigure package.
// Please do not edit.
//
// ********************************************************/

#ifndef __pf_driver__PFDRIVERR2000CONFIG_H__
#define __pf_driver__PFDRIVERR2000CONFIG_H__

#if __cplusplus >= 201103L
#define DYNAMIC_RECONFIGURE_FINAL final
#else
#define DYNAMIC_RECONFIGURE_FINAL
#endif

#include <dynamic_reconfigure/config_tools.h>
#include <limits>
#include <ros/node_handle.h>
#include <dynamic_reconfigure/ConfigDescription.h>
#include <dynamic_reconfigure/ParamDescription.h>
#include <dynamic_reconfigure/Group.h>
#include <dynamic_reconfigure/config_init_mutex.h>
#include <boost/any.hpp>

namespace pf_driver
{
  class PFDriverR2000ConfigStatics;

  class PFDriverR2000Config
  {
  public:
    class AbstractParamDescription : public dynamic_reconfigure::ParamDescription
    {
    public:
      AbstractParamDescription(std::string n, std::string t, uint32_t l,
          std::string d, std::string e)
      {
        name = n;
        type = t;
        level = l;
        description = d;
        edit_method = e;
      }
      virtual ~AbstractParamDescription() = default;

      virtual void clamp(PFDriverR2000Config &config, const PFDriverR2000Config &max, const PFDriverR2000Config &min) const = 0;
      virtual void calcLevel(uint32_t &level, const PFDriverR2000Config &config1, const PFDriverR2000Config &config2) const = 0;
      virtual void fromServer(const ros::NodeHandle &nh, PFDriverR2000Config &config) const = 0;
      virtual void toServer(const ros::NodeHandle &nh, const PFDriverR2000Config &config) const = 0;
      virtual bool fromMessage(const dynamic_reconfigure::Config &msg, PFDriverR2000Config &config) const = 0;
      virtual void toMessage(dynamic_reconfigure::Config &msg, const PFDriverR2000Config &config) const = 0;
      virtual void getValue(const PFDriverR2000Config &config, boost::any &val) const = 0;
    };

    typedef boost::shared_ptr<AbstractParamDescription> AbstractParamDescriptionPtr;
    typedef boost::shared_ptr<const AbstractParamDescription> AbstractParamDescriptionConstPtr;

    // Final keyword added to class because it has virtual methods and inherits
    // from a class with a non-virtual destructor.
    template <class T>
    class ParamDescription DYNAMIC_RECONFIGURE_FINAL : public AbstractParamDescription
    {
    public:
      ParamDescription(std::string a_name, std::string a_type, uint32_t a_level,
          std::string a_description, std::string a_edit_method, T PFDriverR2000Config::* a_f) :
        AbstractParamDescription(a_name, a_type, a_level, a_description, a_edit_method),
        field(a_f)
      {}

      T PFDriverR2000Config::* field;

      virtual void clamp(PFDriverR2000Config &config, const PFDriverR2000Config &max, const PFDriverR2000Config &min) const override
      {
        if (config.*field > max.*field)
          config.*field = max.*field;

        if (config.*field < min.*field)
          config.*field = min.*field;
      }

      virtual void calcLevel(uint32_t &comb_level, const PFDriverR2000Config &config1, const PFDriverR2000Config &config2) const override
      {
        if (config1.*field != config2.*field)
          comb_level |= level;
      }

      virtual void fromServer(const ros::NodeHandle &nh, PFDriverR2000Config &config) const override
      {
        nh.getParam(name, config.*field);
      }

      virtual void toServer(const ros::NodeHandle &nh, const PFDriverR2000Config &config) const override
      {
        nh.setParam(name, config.*field);
      }

      virtual bool fromMessage(const dynamic_reconfigure::Config &msg, PFDriverR2000Config &config) const override
      {
        return dynamic_reconfigure::ConfigTools::getParameter(msg, name, config.*field);
      }

      virtual void toMessage(dynamic_reconfigure::Config &msg, const PFDriverR2000Config &config) const override
      {
        dynamic_reconfigure::ConfigTools::appendParameter(msg, name, config.*field);
      }

      virtual void getValue(const PFDriverR2000Config &config, boost::any &val) const override
      {
        val = config.*field;
      }
    };

    class AbstractGroupDescription : public dynamic_reconfigure::Group
    {
      public:
      AbstractGroupDescription(std::string n, std::string t, int p, int i, bool s)
      {
        name = n;
        type = t;
        parent = p;
        state = s;
        id = i;
      }

      virtual ~AbstractGroupDescription() = default;

      std::vector<AbstractParamDescriptionConstPtr> abstract_parameters;
      bool state;

      virtual void toMessage(dynamic_reconfigure::Config &msg, const boost::any &config) const = 0;
      virtual bool fromMessage(const dynamic_reconfigure::Config &msg, boost::any &config) const =0;
      virtual void updateParams(boost::any &cfg, PFDriverR2000Config &top) const= 0;
      virtual void setInitialState(boost::any &cfg) const = 0;


      void convertParams()
      {
        for(std::vector<AbstractParamDescriptionConstPtr>::const_iterator i = abstract_parameters.begin(); i != abstract_parameters.end(); ++i)
        {
          parameters.push_back(dynamic_reconfigure::ParamDescription(**i));
        }
      }
    };

    typedef boost::shared_ptr<AbstractGroupDescription> AbstractGroupDescriptionPtr;
    typedef boost::shared_ptr<const AbstractGroupDescription> AbstractGroupDescriptionConstPtr;

    // Final keyword added to class because it has virtual methods and inherits
    // from a class with a non-virtual destructor.
    template<class T, class PT>
    class GroupDescription DYNAMIC_RECONFIGURE_FINAL : public AbstractGroupDescription
    {
    public:
      GroupDescription(std::string a_name, std::string a_type, int a_parent, int a_id, bool a_s, T PT::* a_f) : AbstractGroupDescription(a_name, a_type, a_parent, a_id, a_s), field(a_f)
      {
      }

      GroupDescription(const GroupDescription<T, PT>& g): AbstractGroupDescription(g.name, g.type, g.parent, g.id, g.state), field(g.field), groups(g.groups)
      {
        parameters = g.parameters;
        abstract_parameters = g.abstract_parameters;
      }

      virtual bool fromMessage(const dynamic_reconfigure::Config &msg, boost::any &cfg) const override
      {
        PT* config = boost::any_cast<PT*>(cfg);
        if(!dynamic_reconfigure::ConfigTools::getGroupState(msg, name, (*config).*field))
          return false;

        for(std::vector<AbstractGroupDescriptionConstPtr>::const_iterator i = groups.begin(); i != groups.end(); ++i)
        {
          boost::any n = &((*config).*field);
          if(!(*i)->fromMessage(msg, n))
            return false;
        }

        return true;
      }

      virtual void setInitialState(boost::any &cfg) const override
      {
        PT* config = boost::any_cast<PT*>(cfg);
        T* group = &((*config).*field);
        group->state = state;

        for(std::vector<AbstractGroupDescriptionConstPtr>::const_iterator i = groups.begin(); i != groups.end(); ++i)
        {
          boost::any n = boost::any(&((*config).*field));
          (*i)->setInitialState(n);
        }

      }

      virtual void updateParams(boost::any &cfg, PFDriverR2000Config &top) const override
      {
        PT* config = boost::any_cast<PT*>(cfg);

        T* f = &((*config).*field);
        f->setParams(top, abstract_parameters);

        for(std::vector<AbstractGroupDescriptionConstPtr>::const_iterator i = groups.begin(); i != groups.end(); ++i)
        {
          boost::any n = &((*config).*field);
          (*i)->updateParams(n, top);
        }
      }

      virtual void toMessage(dynamic_reconfigure::Config &msg, const boost::any &cfg) const override
      {
        const PT config = boost::any_cast<PT>(cfg);
        dynamic_reconfigure::ConfigTools::appendGroup<T>(msg, name, id, parent, config.*field);

        for(std::vector<AbstractGroupDescriptionConstPtr>::const_iterator i = groups.begin(); i != groups.end(); ++i)
        {
          (*i)->toMessage(msg, config.*field);
        }
      }

      T PT::* field;
      std::vector<PFDriverR2000Config::AbstractGroupDescriptionConstPtr> groups;
    };

class DEFAULT
{
  public:
    DEFAULT()
    {
      state = true;
      name = "Default";
    }

    void setParams(PFDriverR2000Config &config, const std::vector<AbstractParamDescriptionConstPtr> params)
    {
      for (std::vector<AbstractParamDescriptionConstPtr>::const_iterator _i = params.begin(); _i != params.end(); ++_i)
      {
        boost::any val;
        (*_i)->getValue(config, val);

        if("ip_mode"==(*_i)->name){ip_mode = boost::any_cast<int>(val);}
        if("ip_address"==(*_i)->name){ip_address = boost::any_cast<std::string>(val);}
        if("subnet_mask"==(*_i)->name){subnet_mask = boost::any_cast<std::string>(val);}
        if("gateway"==(*_i)->name){gateway = boost::any_cast<std::string>(val);}
        if("scan_frequency"==(*_i)->name){scan_frequency = boost::any_cast<int>(val);}
        if("scan_direction"==(*_i)->name){scan_direction = boost::any_cast<std::string>(val);}
        if("samples_per_scan"==(*_i)->name){samples_per_scan = boost::any_cast<int>(val);}
        if("hmi_display_mode"==(*_i)->name){hmi_display_mode = boost::any_cast<std::string>(val);}
        if("hmi_language"==(*_i)->name){hmi_language = boost::any_cast<std::string>(val);}
        if("hmi_button_lock"==(*_i)->name){hmi_button_lock = boost::any_cast<std::string>(val);}
        if("hmi_parameter_lock"==(*_i)->name){hmi_parameter_lock = boost::any_cast<std::string>(val);}
        if("hmi_static_text_1"==(*_i)->name){hmi_static_text_1 = boost::any_cast<std::string>(val);}
        if("hmi_static_text_2"==(*_i)->name){hmi_static_text_2 = boost::any_cast<std::string>(val);}
        if("locator_indication"==(*_i)->name){locator_indication = boost::any_cast<std::string>(val);}
        if("operating_mode"==(*_i)->name){operating_mode = boost::any_cast<std::string>(val);}
        if("address"==(*_i)->name){address = boost::any_cast<std::string>(val);}
        if("port"==(*_i)->name){port = boost::any_cast<int>(val);}
        if("packet_type"==(*_i)->name){packet_type = boost::any_cast<std::string>(val);}
        if("packet_crc"==(*_i)->name){packet_crc = boost::any_cast<std::string>(val);}
        if("watchdog"==(*_i)->name){watchdog = boost::any_cast<std::string>(val);}
        if("watchdogtimeout"==(*_i)->name){watchdogtimeout = boost::any_cast<int>(val);}
        if("start_angle"==(*_i)->name){start_angle = boost::any_cast<double>(val);}
        if("max_num_points_scan"==(*_i)->name){max_num_points_scan = boost::any_cast<int>(val);}
        if("skip_scans"==(*_i)->name){skip_scans = boost::any_cast<int>(val);}
        if("user_tag"==(*_i)->name){user_tag = boost::any_cast<std::string>(val);}
        if("user_notes"==(*_i)->name){user_notes = boost::any_cast<std::string>(val);}
      }
    }

    int ip_mode;
std::string ip_address;
std::string subnet_mask;
std::string gateway;
int scan_frequency;
std::string scan_direction;
int samples_per_scan;
std::string hmi_display_mode;
std::string hmi_language;
std::string hmi_button_lock;
std::string hmi_parameter_lock;
std::string hmi_static_text_1;
std::string hmi_static_text_2;
std::string locator_indication;
std::string operating_mode;
std::string address;
int port;
std::string packet_type;
std::string packet_crc;
std::string watchdog;
int watchdogtimeout;
double start_angle;
int max_num_points_scan;
int skip_scans;
std::string user_tag;
std::string user_notes;

    bool state;
    std::string name;

    
}groups;



//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      int ip_mode;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      std::string ip_address;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      std::string subnet_mask;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      std::string gateway;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      int scan_frequency;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      std::string scan_direction;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      int samples_per_scan;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      std::string hmi_display_mode;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      std::string hmi_language;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      std::string hmi_button_lock;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      std::string hmi_parameter_lock;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      std::string hmi_static_text_1;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      std::string hmi_static_text_2;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      std::string locator_indication;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      std::string operating_mode;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      std::string address;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      int port;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      std::string packet_type;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      std::string packet_crc;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      std::string watchdog;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      int watchdogtimeout;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      double start_angle;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      int max_num_points_scan;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      int skip_scans;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      std::string user_tag;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      std::string user_notes;
//#line 231 "/opt/ros/noetic/share/dynamic_reconfigure/cmake/../templates/ConfigType.h.template"

    bool __fromMessage__(dynamic_reconfigure::Config &msg)
    {
      const std::vector<AbstractParamDescriptionConstPtr> &__param_descriptions__ = __getParamDescriptions__();
      const std::vector<AbstractGroupDescriptionConstPtr> &__group_descriptions__ = __getGroupDescriptions__();

      int count = 0;
      for (std::vector<AbstractParamDescriptionConstPtr>::const_iterator i = __param_descriptions__.begin(); i != __param_descriptions__.end(); ++i)
        if ((*i)->fromMessage(msg, *this))
          count++;

      for (std::vector<AbstractGroupDescriptionConstPtr>::const_iterator i = __group_descriptions__.begin(); i != __group_descriptions__.end(); i ++)
      {
        if ((*i)->id == 0)
        {
          boost::any n = boost::any(this);
          (*i)->updateParams(n, *this);
          (*i)->fromMessage(msg, n);
        }
      }

      if (count != dynamic_reconfigure::ConfigTools::size(msg))
      {
        ROS_ERROR("PFDriverR2000Config::__fromMessage__ called with an unexpected parameter.");
        ROS_ERROR("Booleans:");
        for (unsigned int i = 0; i < msg.bools.size(); i++)
          ROS_ERROR("  %s", msg.bools[i].name.c_str());
        ROS_ERROR("Integers:");
        for (unsigned int i = 0; i < msg.ints.size(); i++)
          ROS_ERROR("  %s", msg.ints[i].name.c_str());
        ROS_ERROR("Doubles:");
        for (unsigned int i = 0; i < msg.doubles.size(); i++)
          ROS_ERROR("  %s", msg.doubles[i].name.c_str());
        ROS_ERROR("Strings:");
        for (unsigned int i = 0; i < msg.strs.size(); i++)
          ROS_ERROR("  %s", msg.strs[i].name.c_str());
        // @todo Check that there are no duplicates. Make this error more
        // explicit.
        return false;
      }
      return true;
    }

    // This version of __toMessage__ is used during initialization of
    // statics when __getParamDescriptions__ can't be called yet.
    void __toMessage__(dynamic_reconfigure::Config &msg, const std::vector<AbstractParamDescriptionConstPtr> &__param_descriptions__, const std::vector<AbstractGroupDescriptionConstPtr> &__group_descriptions__) const
    {
      dynamic_reconfigure::ConfigTools::clear(msg);
      for (std::vector<AbstractParamDescriptionConstPtr>::const_iterator i = __param_descriptions__.begin(); i != __param_descriptions__.end(); ++i)
        (*i)->toMessage(msg, *this);

      for (std::vector<AbstractGroupDescriptionConstPtr>::const_iterator i = __group_descriptions__.begin(); i != __group_descriptions__.end(); ++i)
      {
        if((*i)->id == 0)
        {
          (*i)->toMessage(msg, *this);
        }
      }
    }

    void __toMessage__(dynamic_reconfigure::Config &msg) const
    {
      const std::vector<AbstractParamDescriptionConstPtr> &__param_descriptions__ = __getParamDescriptions__();
      const std::vector<AbstractGroupDescriptionConstPtr> &__group_descriptions__ = __getGroupDescriptions__();
      __toMessage__(msg, __param_descriptions__, __group_descriptions__);
    }

    void __toServer__(const ros::NodeHandle &nh) const
    {
      const std::vector<AbstractParamDescriptionConstPtr> &__param_descriptions__ = __getParamDescriptions__();
      for (std::vector<AbstractParamDescriptionConstPtr>::const_iterator i = __param_descriptions__.begin(); i != __param_descriptions__.end(); ++i)
        (*i)->toServer(nh, *this);
    }

    void __fromServer__(const ros::NodeHandle &nh)
    {
      static bool setup=false;

      const std::vector<AbstractParamDescriptionConstPtr> &__param_descriptions__ = __getParamDescriptions__();
      for (std::vector<AbstractParamDescriptionConstPtr>::const_iterator i = __param_descriptions__.begin(); i != __param_descriptions__.end(); ++i)
        (*i)->fromServer(nh, *this);

      const std::vector<AbstractGroupDescriptionConstPtr> &__group_descriptions__ = __getGroupDescriptions__();
      for (std::vector<AbstractGroupDescriptionConstPtr>::const_iterator i = __group_descriptions__.begin(); i != __group_descriptions__.end(); i++){
        if (!setup && (*i)->id == 0) {
          setup = true;
          boost::any n = boost::any(this);
          (*i)->setInitialState(n);
        }
      }
    }

    void __clamp__()
    {
      const std::vector<AbstractParamDescriptionConstPtr> &__param_descriptions__ = __getParamDescriptions__();
      const PFDriverR2000Config &__max__ = __getMax__();
      const PFDriverR2000Config &__min__ = __getMin__();
      for (std::vector<AbstractParamDescriptionConstPtr>::const_iterator i = __param_descriptions__.begin(); i != __param_descriptions__.end(); ++i)
        (*i)->clamp(*this, __max__, __min__);
    }

    uint32_t __level__(const PFDriverR2000Config &config) const
    {
      const std::vector<AbstractParamDescriptionConstPtr> &__param_descriptions__ = __getParamDescriptions__();
      uint32_t level = 0;
      for (std::vector<AbstractParamDescriptionConstPtr>::const_iterator i = __param_descriptions__.begin(); i != __param_descriptions__.end(); ++i)
        (*i)->calcLevel(level, config, *this);
      return level;
    }

    static const dynamic_reconfigure::ConfigDescription &__getDescriptionMessage__();
    static const PFDriverR2000Config &__getDefault__();
    static const PFDriverR2000Config &__getMax__();
    static const PFDriverR2000Config &__getMin__();
    static const std::vector<AbstractParamDescriptionConstPtr> &__getParamDescriptions__();
    static const std::vector<AbstractGroupDescriptionConstPtr> &__getGroupDescriptions__();

  private:
    static const PFDriverR2000ConfigStatics *__get_statics__();
  };

  template <> // Max and min are ignored for strings.
  inline void PFDriverR2000Config::ParamDescription<std::string>::clamp(PFDriverR2000Config &config, const PFDriverR2000Config &max, const PFDriverR2000Config &min) const
  {
    (void) config;
    (void) min;
    (void) max;
    return;
  }

  class PFDriverR2000ConfigStatics
  {
    friend class PFDriverR2000Config;

    PFDriverR2000ConfigStatics()
    {
PFDriverR2000Config::GroupDescription<PFDriverR2000Config::DEFAULT, PFDriverR2000Config> Default("Default", "", 0, 0, true, &PFDriverR2000Config::groups);
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __min__.ip_mode = -2147483648;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __max__.ip_mode = 2147483647;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __default__.ip_mode = 2;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      Default.abstract_parameters.push_back(PFDriverR2000Config::AbstractParamDescriptionConstPtr(new PFDriverR2000Config::ParamDescription<int>("ip_mode", "int", 1, "ip_mode value determines the method used by the device to determine its own IP and network conﬁguration.", "{'enum': [{'name': 'static', 'type': 'int', 'value': 0, 'srcline': 11, 'srcfile': '/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2000.cfg', 'description': 'Static IP mode', 'ctype': 'int', 'cconsttype': 'const int'}, {'name': 'dhcp', 'type': 'int', 'value': 1, 'srcline': 12, 'srcfile': '/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2000.cfg', 'description': 'DHCP IP mode', 'ctype': 'int', 'cconsttype': 'const int'}, {'name': 'autoip', 'type': 'int', 'value': 2, 'srcline': 13, 'srcfile': '/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2000.cfg', 'description': 'AutoIP mode', 'ctype': 'int', 'cconsttype': 'const int'}], 'enum_description': 'An enum to set IP mode'}", &PFDriverR2000Config::ip_mode)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __param_descriptions__.push_back(PFDriverR2000Config::AbstractParamDescriptionConstPtr(new PFDriverR2000Config::ParamDescription<int>("ip_mode", "int", 1, "ip_mode value determines the method used by the device to determine its own IP and network conﬁguration.", "{'enum': [{'name': 'static', 'type': 'int', 'value': 0, 'srcline': 11, 'srcfile': '/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2000.cfg', 'description': 'Static IP mode', 'ctype': 'int', 'cconsttype': 'const int'}, {'name': 'dhcp', 'type': 'int', 'value': 1, 'srcline': 12, 'srcfile': '/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2000.cfg', 'description': 'DHCP IP mode', 'ctype': 'int', 'cconsttype': 'const int'}, {'name': 'autoip', 'type': 'int', 'value': 2, 'srcline': 13, 'srcfile': '/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2000.cfg', 'description': 'AutoIP mode', 'ctype': 'int', 'cconsttype': 'const int'}], 'enum_description': 'An enum to set IP mode'}", &PFDriverR2000Config::ip_mode)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __min__.ip_address = "";
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __max__.ip_address = "";
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __default__.ip_address = "10.0.10.9";
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      Default.abstract_parameters.push_back(PFDriverR2000Config::AbstractParamDescriptionConstPtr(new PFDriverR2000Config::ParamDescription<std::string>("ip_address", "str", 2, "IP address", "", &PFDriverR2000Config::ip_address)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __param_descriptions__.push_back(PFDriverR2000Config::AbstractParamDescriptionConstPtr(new PFDriverR2000Config::ParamDescription<std::string>("ip_address", "str", 2, "IP address", "", &PFDriverR2000Config::ip_address)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __min__.subnet_mask = "";
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __max__.subnet_mask = "";
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __default__.subnet_mask = "255.0.0.0";
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      Default.abstract_parameters.push_back(PFDriverR2000Config::AbstractParamDescriptionConstPtr(new PFDriverR2000Config::ParamDescription<std::string>("subnet_mask", "str", 3, "IP netmask", "", &PFDriverR2000Config::subnet_mask)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __param_descriptions__.push_back(PFDriverR2000Config::AbstractParamDescriptionConstPtr(new PFDriverR2000Config::ParamDescription<std::string>("subnet_mask", "str", 3, "IP netmask", "", &PFDriverR2000Config::subnet_mask)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __min__.gateway = "";
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __max__.gateway = "";
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __default__.gateway = "0.0.0.0";
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      Default.abstract_parameters.push_back(PFDriverR2000Config::AbstractParamDescriptionConstPtr(new PFDriverR2000Config::ParamDescription<std::string>("gateway", "str", 4, "IP gateway", "", &PFDriverR2000Config::gateway)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __param_descriptions__.push_back(PFDriverR2000Config::AbstractParamDescriptionConstPtr(new PFDriverR2000Config::ParamDescription<std::string>("gateway", "str", 4, "IP gateway", "", &PFDriverR2000Config::gateway)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __min__.scan_frequency = 10;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __max__.scan_frequency = 50;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __default__.scan_frequency = 35;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      Default.abstract_parameters.push_back(PFDriverR2000Config::AbstractParamDescriptionConstPtr(new PFDriverR2000Config::ParamDescription<int>("scan_frequency", "int", 5, "The parameter scan_frequency defines the set point for the rotational speed of the sensor head and therefore the number of scans recorded per second. For the R2000 valid values range from 10 Hz to 50 Hz with steps of 1 Hz.", "", &PFDriverR2000Config::scan_frequency)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __param_descriptions__.push_back(PFDriverR2000Config::AbstractParamDescriptionConstPtr(new PFDriverR2000Config::ParamDescription<int>("scan_frequency", "int", 5, "The parameter scan_frequency defines the set point for the rotational speed of the sensor head and therefore the number of scans recorded per second. For the R2000 valid values range from 10 Hz to 50 Hz with steps of 1 Hz.", "", &PFDriverR2000Config::scan_frequency)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __min__.scan_direction = "";
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __max__.scan_direction = "";
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __default__.scan_direction = "ccw";
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      Default.abstract_parameters.push_back(PFDriverR2000Config::AbstractParamDescriptionConstPtr(new PFDriverR2000Config::ParamDescription<std::string>("scan_direction", "str", 6, "The parameter scan_direction defines the direction of rotation of the sensors head. User applications can choose between clockwise rotation (cw) or counter-clockwise rotation (ccw).", "{'enum': [{'name': 'cw', 'type': 'str', 'value': 'cw', 'srcline': 21, 'srcfile': '/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2000.cfg', 'description': 'Clock-wise', 'ctype': 'std::string', 'cconsttype': 'const char * const'}, {'name': 'ccw', 'type': 'str', 'value': 'ccw', 'srcline': 22, 'srcfile': '/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2000.cfg', 'description': 'Counter clock-wise', 'ctype': 'std::string', 'cconsttype': 'const char * const'}], 'enum_description': 'An enum to set scan direction'}", &PFDriverR2000Config::scan_direction)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __param_descriptions__.push_back(PFDriverR2000Config::AbstractParamDescriptionConstPtr(new PFDriverR2000Config::ParamDescription<std::string>("scan_direction", "str", 6, "The parameter scan_direction defines the direction of rotation of the sensors head. User applications can choose between clockwise rotation (cw) or counter-clockwise rotation (ccw).", "{'enum': [{'name': 'cw', 'type': 'str', 'value': 'cw', 'srcline': 21, 'srcfile': '/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2000.cfg', 'description': 'Clock-wise', 'ctype': 'std::string', 'cconsttype': 'const char * const'}, {'name': 'ccw', 'type': 'str', 'value': 'ccw', 'srcline': 22, 'srcfile': '/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2000.cfg', 'description': 'Counter clock-wise', 'ctype': 'std::string', 'cconsttype': 'const char * const'}], 'enum_description': 'An enum to set scan direction'}", &PFDriverR2000Config::scan_direction)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __min__.samples_per_scan = 72;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __max__.samples_per_scan = 25200;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __default__.samples_per_scan = 3600;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      Default.abstract_parameters.push_back(PFDriverR2000Config::AbstractParamDescriptionConstPtr(new PFDriverR2000Config::ParamDescription<int>("samples_per_scan", "int", 7, "The parameter samples_per_scan defines the number of samples recorded during one revolution of the sensor head (for details please refer to section 3.1 in the R2000 Ethernet communication protocol).", "", &PFDriverR2000Config::samples_per_scan)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __param_descriptions__.push_back(PFDriverR2000Config::AbstractParamDescriptionConstPtr(new PFDriverR2000Config::ParamDescription<int>("samples_per_scan", "int", 7, "The parameter samples_per_scan defines the number of samples recorded during one revolution of the sensor head (for details please refer to section 3.1 in the R2000 Ethernet communication protocol).", "", &PFDriverR2000Config::samples_per_scan)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __min__.hmi_display_mode = "";
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __max__.hmi_display_mode = "";
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __default__.hmi_display_mode = "static_logo";
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      Default.abstract_parameters.push_back(PFDriverR2000Config::AbstractParamDescriptionConstPtr(new PFDriverR2000Config::ParamDescription<std::string>("hmi_display_mode", "str", 8, "The parameter hmi_display_mode controls the content of the HMI LED display during normal operation, i.e. while neither warnings nor errors are displayed and the user did not activate the HMI menu.", "{'enum': [{'name': 'hmi_display_off', 'type': 'str', 'value': 'off', 'srcline': 63, 'srcfile': '/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2000.cfg', 'description': '', 'ctype': 'std::string', 'cconsttype': 'const char * const'}, {'name': 'static_logo', 'type': 'str', 'value': 'static_logo', 'srcline': 64, 'srcfile': '/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2000.cfg', 'description': '', 'ctype': 'std::string', 'cconsttype': 'const char * const'}, {'name': 'static_text', 'type': 'str', 'value': 'static_text', 'srcline': 65, 'srcfile': '/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2000.cfg', 'description': '', 'ctype': 'std::string', 'cconsttype': 'const char * const'}, {'name': 'bargraph_distance', 'type': 'str', 'value': 'bargraph_distance', 'srcline': 66, 'srcfile': '/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2000.cfg', 'description': '', 'ctype': 'std::string', 'cconsttype': 'const char * const'}, {'name': 'bargraph_echo', 'type': 'str', 'value': 'bargraph_echo', 'srcline': 67, 'srcfile': '/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2000.cfg', 'description': '', 'ctype': 'std::string', 'cconsttype': 'const char * const'}, {'name': 'bargraph_reflector', 'type': 'str', 'value': 'bargraph_reflector', 'srcline': 68, 'srcfile': '/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2000.cfg', 'description': '', 'ctype': 'std::string', 'cconsttype': 'const char * const'}, {'name': 'application_bitmap', 'type': 'str', 'value': 'application_bitmap', 'srcline': 69, 'srcfile': '/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2000.cfg', 'description': '', 'ctype': 'std::string', 'cconsttype': 'const char * const'}, {'name': 'application_text', 'type': 'str', 'value': 'application_text', 'srcline': 70, 'srcfile': '/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2000.cfg', 'description': '', 'ctype': 'std::string', 'cconsttype': 'const char * const'}], 'enum_description': 'An enum to set hmi display mode'}", &PFDriverR2000Config::hmi_display_mode)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __param_descriptions__.push_back(PFDriverR2000Config::AbstractParamDescriptionConstPtr(new PFDriverR2000Config::ParamDescription<std::string>("hmi_display_mode", "str", 8, "The parameter hmi_display_mode controls the content of the HMI LED display during normal operation, i.e. while neither warnings nor errors are displayed and the user did not activate the HMI menu.", "{'enum': [{'name': 'hmi_display_off', 'type': 'str', 'value': 'off', 'srcline': 63, 'srcfile': '/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2000.cfg', 'description': '', 'ctype': 'std::string', 'cconsttype': 'const char * const'}, {'name': 'static_logo', 'type': 'str', 'value': 'static_logo', 'srcline': 64, 'srcfile': '/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2000.cfg', 'description': '', 'ctype': 'std::string', 'cconsttype': 'const char * const'}, {'name': 'static_text', 'type': 'str', 'value': 'static_text', 'srcline': 65, 'srcfile': '/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2000.cfg', 'description': '', 'ctype': 'std::string', 'cconsttype': 'const char * const'}, {'name': 'bargraph_distance', 'type': 'str', 'value': 'bargraph_distance', 'srcline': 66, 'srcfile': '/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2000.cfg', 'description': '', 'ctype': 'std::string', 'cconsttype': 'const char * const'}, {'name': 'bargraph_echo', 'type': 'str', 'value': 'bargraph_echo', 'srcline': 67, 'srcfile': '/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2000.cfg', 'description': '', 'ctype': 'std::string', 'cconsttype': 'const char * const'}, {'name': 'bargraph_reflector', 'type': 'str', 'value': 'bargraph_reflector', 'srcline': 68, 'srcfile': '/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2000.cfg', 'description': '', 'ctype': 'std::string', 'cconsttype': 'const char * const'}, {'name': 'application_bitmap', 'type': 'str', 'value': 'application_bitmap', 'srcline': 69, 'srcfile': '/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2000.cfg', 'description': '', 'ctype': 'std::string', 'cconsttype': 'const char * const'}, {'name': 'application_text', 'type': 'str', 'value': 'application_text', 'srcline': 70, 'srcfile': '/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2000.cfg', 'description': '', 'ctype': 'std::string', 'cconsttype': 'const char * const'}], 'enum_description': 'An enum to set hmi display mode'}", &PFDriverR2000Config::hmi_display_mode)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __min__.hmi_language = "";
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __max__.hmi_language = "";
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __default__.hmi_language = "english";
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      Default.abstract_parameters.push_back(PFDriverR2000Config::AbstractParamDescriptionConstPtr(new PFDriverR2000Config::ParamDescription<std::string>("hmi_language", "str", 9, "change display language", "{'enum': [{'name': 'english', 'type': 'str', 'value': 'english', 'srcline': 74, 'srcfile': '/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2000.cfg', 'description': '', 'ctype': 'std::string', 'cconsttype': 'const char * const'}, {'name': 'german', 'type': 'str', 'value': 'german', 'srcline': 75, 'srcfile': '/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2000.cfg', 'description': '', 'ctype': 'std::string', 'cconsttype': 'const char * const'}], 'enum_description': 'An enum to set hmi language'}", &PFDriverR2000Config::hmi_language)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __param_descriptions__.push_back(PFDriverR2000Config::AbstractParamDescriptionConstPtr(new PFDriverR2000Config::ParamDescription<std::string>("hmi_language", "str", 9, "change display language", "{'enum': [{'name': 'english', 'type': 'str', 'value': 'english', 'srcline': 74, 'srcfile': '/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2000.cfg', 'description': '', 'ctype': 'std::string', 'cconsttype': 'const char * const'}, {'name': 'german', 'type': 'str', 'value': 'german', 'srcline': 75, 'srcfile': '/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2000.cfg', 'description': '', 'ctype': 'std::string', 'cconsttype': 'const char * const'}], 'enum_description': 'An enum to set hmi language'}", &PFDriverR2000Config::hmi_language)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __min__.hmi_button_lock = "";
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __max__.hmi_button_lock = "";
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __default__.hmi_button_lock = "off";
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      Default.abstract_parameters.push_back(PFDriverR2000Config::AbstractParamDescriptionConstPtr(new PFDriverR2000Config::ParamDescription<std::string>("hmi_button_lock", "str", 10, "lock HMI buttons", "{'enum': [{'name': 'hmi_button_lock_on', 'type': 'str', 'value': 'on', 'srcline': 79, 'srcfile': '/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2000.cfg', 'description': 'hmi button lock on', 'ctype': 'std::string', 'cconsttype': 'const char * const'}, {'name': 'hmi_button_lock_off', 'type': 'str', 'value': 'off', 'srcline': 80, 'srcfile': '/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2000.cfg', 'description': 'hmi button lock off', 'ctype': 'std::string', 'cconsttype': 'const char * const'}], 'enum_description': 'An enum to set hmi button lock'}", &PFDriverR2000Config::hmi_button_lock)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __param_descriptions__.push_back(PFDriverR2000Config::AbstractParamDescriptionConstPtr(new PFDriverR2000Config::ParamDescription<std::string>("hmi_button_lock", "str", 10, "lock HMI buttons", "{'enum': [{'name': 'hmi_button_lock_on', 'type': 'str', 'value': 'on', 'srcline': 79, 'srcfile': '/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2000.cfg', 'description': 'hmi button lock on', 'ctype': 'std::string', 'cconsttype': 'const char * const'}, {'name': 'hmi_button_lock_off', 'type': 'str', 'value': 'off', 'srcline': 80, 'srcfile': '/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2000.cfg', 'description': 'hmi button lock off', 'ctype': 'std::string', 'cconsttype': 'const char * const'}], 'enum_description': 'An enum to set hmi button lock'}", &PFDriverR2000Config::hmi_button_lock)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __min__.hmi_parameter_lock = "";
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __max__.hmi_parameter_lock = "";
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __default__.hmi_parameter_lock = "off";
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      Default.abstract_parameters.push_back(PFDriverR2000Config::AbstractParamDescriptionConstPtr(new PFDriverR2000Config::ParamDescription<std::string>("hmi_parameter_lock", "str", 11, "set HMI to read-only", "{'enum': [{'name': 'hmi_parameter_lock_on', 'type': 'str', 'value': 'on', 'srcline': 84, 'srcfile': '/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2000.cfg', 'description': 'hmi parameter lock on', 'ctype': 'std::string', 'cconsttype': 'const char * const'}, {'name': 'hmi_parameter_lock_off', 'type': 'str', 'value': 'off', 'srcline': 85, 'srcfile': '/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2000.cfg', 'description': 'hmi parameter lock off', 'ctype': 'std::string', 'cconsttype': 'const char * const'}], 'enum_description': 'An enum to set hmi parameter lock'}", &PFDriverR2000Config::hmi_parameter_lock)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __param_descriptions__.push_back(PFDriverR2000Config::AbstractParamDescriptionConstPtr(new PFDriverR2000Config::ParamDescription<std::string>("hmi_parameter_lock", "str", 11, "set HMI to read-only", "{'enum': [{'name': 'hmi_parameter_lock_on', 'type': 'str', 'value': 'on', 'srcline': 84, 'srcfile': '/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2000.cfg', 'description': 'hmi parameter lock on', 'ctype': 'std::string', 'cconsttype': 'const char * const'}, {'name': 'hmi_parameter_lock_off', 'type': 'str', 'value': 'off', 'srcline': 85, 'srcfile': '/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2000.cfg', 'description': 'hmi parameter lock off', 'ctype': 'std::string', 'cconsttype': 'const char * const'}], 'enum_description': 'An enum to set hmi parameter lock'}", &PFDriverR2000Config::hmi_parameter_lock)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __min__.hmi_static_text_1 = "";
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __max__.hmi_static_text_1 = "";
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __default__.hmi_static_text_1 = "Pepperl+Fuchs";
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      Default.abstract_parameters.push_back(PFDriverR2000Config::AbstractParamDescriptionConstPtr(new PFDriverR2000Config::ParamDescription<std::string>("hmi_static_text_1", "str", 12, "text line 1 for mode static_text (max. 30 chars)", "", &PFDriverR2000Config::hmi_static_text_1)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __param_descriptions__.push_back(PFDriverR2000Config::AbstractParamDescriptionConstPtr(new PFDriverR2000Config::ParamDescription<std::string>("hmi_static_text_1", "str", 12, "text line 1 for mode static_text (max. 30 chars)", "", &PFDriverR2000Config::hmi_static_text_1)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __min__.hmi_static_text_2 = "";
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __max__.hmi_static_text_2 = "";
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __default__.hmi_static_text_2 = "R2000";
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      Default.abstract_parameters.push_back(PFDriverR2000Config::AbstractParamDescriptionConstPtr(new PFDriverR2000Config::ParamDescription<std::string>("hmi_static_text_2", "str", 13, "text line 2 for mode static_text (max. 30 chars)", "", &PFDriverR2000Config::hmi_static_text_2)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __param_descriptions__.push_back(PFDriverR2000Config::AbstractParamDescriptionConstPtr(new PFDriverR2000Config::ParamDescription<std::string>("hmi_static_text_2", "str", 13, "text line 2 for mode static_text (max. 30 chars)", "", &PFDriverR2000Config::hmi_static_text_2)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __min__.locator_indication = "";
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __max__.locator_indication = "";
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __default__.locator_indication = "off";
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      Default.abstract_parameters.push_back(PFDriverR2000Config::AbstractParamDescriptionConstPtr(new PFDriverR2000Config::ParamDescription<std::string>("locator_indication", "str", 14, "LED locator indication", "{'enum': [{'name': 'locator_indicator_on', 'type': 'str', 'value': 'on', 'srcline': 91, 'srcfile': '/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2000.cfg', 'description': 'locator indicator on', 'ctype': 'std::string', 'cconsttype': 'const char * const'}, {'name': 'locator_indicator_off', 'type': 'str', 'value': 'off', 'srcline': 92, 'srcfile': '/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2000.cfg', 'description': 'locator indicator off', 'ctype': 'std::string', 'cconsttype': 'const char * const'}], 'enum_description': 'An enum to set locator indicator'}", &PFDriverR2000Config::locator_indication)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __param_descriptions__.push_back(PFDriverR2000Config::AbstractParamDescriptionConstPtr(new PFDriverR2000Config::ParamDescription<std::string>("locator_indication", "str", 14, "LED locator indication", "{'enum': [{'name': 'locator_indicator_on', 'type': 'str', 'value': 'on', 'srcline': 91, 'srcfile': '/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2000.cfg', 'description': 'locator indicator on', 'ctype': 'std::string', 'cconsttype': 'const char * const'}, {'name': 'locator_indicator_off', 'type': 'str', 'value': 'off', 'srcline': 92, 'srcfile': '/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2000.cfg', 'description': 'locator indicator off', 'ctype': 'std::string', 'cconsttype': 'const char * const'}], 'enum_description': 'An enum to set locator indicator'}", &PFDriverR2000Config::locator_indication)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __min__.operating_mode = "";
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __max__.operating_mode = "";
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __default__.operating_mode = "measure";
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      Default.abstract_parameters.push_back(PFDriverR2000Config::AbstractParamDescriptionConstPtr(new PFDriverR2000Config::ParamDescription<std::string>("operating_mode", "str", 15, "The operating_mode, always measure after power on, can be temporarily set to emitter_off to disable the laser pulse, e.g. in order to avoid affecting other scanners.", "{'enum': [{'name': 'measure', 'type': 'str', 'value': 'measure', 'srcline': 96, 'srcfile': '/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2000.cfg', 'description': 'measure mode', 'ctype': 'std::string', 'cconsttype': 'const char * const'}, {'name': 'emitter_off', 'type': 'str', 'value': 'emitter_off', 'srcline': 97, 'srcfile': '/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2000.cfg', 'description': 'emitter_off mode', 'ctype': 'std::string', 'cconsttype': 'const char * const'}], 'enum_description': 'An enum to set operating mode'}", &PFDriverR2000Config::operating_mode)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __param_descriptions__.push_back(PFDriverR2000Config::AbstractParamDescriptionConstPtr(new PFDriverR2000Config::ParamDescription<std::string>("operating_mode", "str", 15, "The operating_mode, always measure after power on, can be temporarily set to emitter_off to disable the laser pulse, e.g. in order to avoid affecting other scanners.", "{'enum': [{'name': 'measure', 'type': 'str', 'value': 'measure', 'srcline': 96, 'srcfile': '/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2000.cfg', 'description': 'measure mode', 'ctype': 'std::string', 'cconsttype': 'const char * const'}, {'name': 'emitter_off', 'type': 'str', 'value': 'emitter_off', 'srcline': 97, 'srcfile': '/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2000.cfg', 'description': 'emitter_off mode', 'ctype': 'std::string', 'cconsttype': 'const char * const'}], 'enum_description': 'An enum to set operating mode'}", &PFDriverR2000Config::operating_mode)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __min__.address = "";
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __max__.address = "";
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __default__.address = "";
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      Default.abstract_parameters.push_back(PFDriverR2000Config::AbstractParamDescriptionConstPtr(new PFDriverR2000Config::ParamDescription<std::string>("address", "str", 16, "When initiating scan data output, request_handle_udp must be given an IPv4 address and port in order to know where to send scandata to.", "", &PFDriverR2000Config::address)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __param_descriptions__.push_back(PFDriverR2000Config::AbstractParamDescriptionConstPtr(new PFDriverR2000Config::ParamDescription<std::string>("address", "str", 16, "When initiating scan data output, request_handle_udp must be given an IPv4 address and port in order to know where to send scandata to.", "", &PFDriverR2000Config::address)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __min__.port = -2147483648;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __max__.port = 2147483647;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __default__.port = 0;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      Default.abstract_parameters.push_back(PFDriverR2000Config::AbstractParamDescriptionConstPtr(new PFDriverR2000Config::ParamDescription<int>("port", "int", 17, "See address", "", &PFDriverR2000Config::port)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __param_descriptions__.push_back(PFDriverR2000Config::AbstractParamDescriptionConstPtr(new PFDriverR2000Config::ParamDescription<int>("port", "int", 17, "See address", "", &PFDriverR2000Config::port)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __min__.packet_type = "";
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __max__.packet_type = "";
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __default__.packet_type = "A";
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      Default.abstract_parameters.push_back(PFDriverR2000Config::AbstractParamDescriptionConstPtr(new PFDriverR2000Config::ParamDescription<std::string>("packet_type", "str", 18, "Packet type for scan data output", "{'enum': [{'name': 'packet_type_A', 'type': 'str', 'value': 'A', 'srcline': 103, 'srcfile': '/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2000.cfg', 'description': 'packet type A', 'ctype': 'std::string', 'cconsttype': 'const char * const'}, {'name': 'packet_type_B', 'type': 'str', 'value': 'B', 'srcline': 104, 'srcfile': '/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2000.cfg', 'description': 'packet type B', 'ctype': 'std::string', 'cconsttype': 'const char * const'}, {'name': 'packet_type_C', 'type': 'str', 'value': 'C', 'srcline': 105, 'srcfile': '/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2000.cfg', 'description': 'packettype C', 'ctype': 'std::string', 'cconsttype': 'const char * const'}], 'enum_description': 'An enum to set packet type'}", &PFDriverR2000Config::packet_type)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __param_descriptions__.push_back(PFDriverR2000Config::AbstractParamDescriptionConstPtr(new PFDriverR2000Config::ParamDescription<std::string>("packet_type", "str", 18, "Packet type for scan data output", "{'enum': [{'name': 'packet_type_A', 'type': 'str', 'value': 'A', 'srcline': 103, 'srcfile': '/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2000.cfg', 'description': 'packet type A', 'ctype': 'std::string', 'cconsttype': 'const char * const'}, {'name': 'packet_type_B', 'type': 'str', 'value': 'B', 'srcline': 104, 'srcfile': '/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2000.cfg', 'description': 'packet type B', 'ctype': 'std::string', 'cconsttype': 'const char * const'}, {'name': 'packet_type_C', 'type': 'str', 'value': 'C', 'srcline': 105, 'srcfile': '/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2000.cfg', 'description': 'packettype C', 'ctype': 'std::string', 'cconsttype': 'const char * const'}], 'enum_description': 'An enum to set packet type'}", &PFDriverR2000Config::packet_type)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __min__.packet_crc = "";
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __max__.packet_crc = "";
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __default__.packet_crc = "";
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      Default.abstract_parameters.push_back(PFDriverR2000Config::AbstractParamDescriptionConstPtr(new PFDriverR2000Config::ParamDescription<std::string>("packet_crc", "str", 19, "Append extra CRC32 for scan data integrity check", "", &PFDriverR2000Config::packet_crc)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __param_descriptions__.push_back(PFDriverR2000Config::AbstractParamDescriptionConstPtr(new PFDriverR2000Config::ParamDescription<std::string>("packet_crc", "str", 19, "Append extra CRC32 for scan data integrity check", "", &PFDriverR2000Config::packet_crc)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __min__.watchdog = "";
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __max__.watchdog = "";
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __default__.watchdog = "off";
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      Default.abstract_parameters.push_back(PFDriverR2000Config::AbstractParamDescriptionConstPtr(new PFDriverR2000Config::ParamDescription<std::string>("watchdog", "str", 20, "Cease scan data output if watchdog isn't fed in time", "{'enum': [{'name': 'watchdog_on', 'type': 'str', 'value': 'on', 'srcline': 109, 'srcfile': '/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2000.cfg', 'description': 'watchdog on', 'ctype': 'std::string', 'cconsttype': 'const char * const'}, {'name': 'watchdog_off', 'type': 'str', 'value': 'off', 'srcline': 110, 'srcfile': '/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2000.cfg', 'description': 'watchdog off', 'ctype': 'std::string', 'cconsttype': 'const char * const'}], 'enum_description': 'An enum to set operating mode'}", &PFDriverR2000Config::watchdog)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __param_descriptions__.push_back(PFDriverR2000Config::AbstractParamDescriptionConstPtr(new PFDriverR2000Config::ParamDescription<std::string>("watchdog", "str", 20, "Cease scan data output if watchdog isn't fed in time", "{'enum': [{'name': 'watchdog_on', 'type': 'str', 'value': 'on', 'srcline': 109, 'srcfile': '/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2000.cfg', 'description': 'watchdog on', 'ctype': 'std::string', 'cconsttype': 'const char * const'}, {'name': 'watchdog_off', 'type': 'str', 'value': 'off', 'srcline': 110, 'srcfile': '/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2000.cfg', 'description': 'watchdog off', 'ctype': 'std::string', 'cconsttype': 'const char * const'}], 'enum_description': 'An enum to set operating mode'}", &PFDriverR2000Config::watchdog)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __min__.watchdogtimeout = -2147483648;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __max__.watchdogtimeout = 2147483647;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __default__.watchdogtimeout = 60000;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      Default.abstract_parameters.push_back(PFDriverR2000Config::AbstractParamDescriptionConstPtr(new PFDriverR2000Config::ParamDescription<int>("watchdogtimeout", "int", 21, "Maximum time for client to feed watchdog", "", &PFDriverR2000Config::watchdogtimeout)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __param_descriptions__.push_back(PFDriverR2000Config::AbstractParamDescriptionConstPtr(new PFDriverR2000Config::ParamDescription<int>("watchdogtimeout", "int", 21, "Maximum time for client to feed watchdog", "", &PFDriverR2000Config::watchdogtimeout)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __min__.start_angle = -std::numeric_limits<double>::infinity();
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __max__.start_angle = std::numeric_limits<double>::infinity();
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __default__.start_angle = -1800000.0;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      Default.abstract_parameters.push_back(PFDriverR2000Config::AbstractParamDescriptionConstPtr(new PFDriverR2000Config::ParamDescription<double>("start_angle", "double", 22, "angle of first scan point for scan data output", "", &PFDriverR2000Config::start_angle)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __param_descriptions__.push_back(PFDriverR2000Config::AbstractParamDescriptionConstPtr(new PFDriverR2000Config::ParamDescription<double>("start_angle", "double", 22, "angle of first scan point for scan data output", "", &PFDriverR2000Config::start_angle)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __min__.max_num_points_scan = -2147483648;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __max__.max_num_points_scan = 2147483647;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __default__.max_num_points_scan = 0;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      Default.abstract_parameters.push_back(PFDriverR2000Config::AbstractParamDescriptionConstPtr(new PFDriverR2000Config::ParamDescription<int>("max_num_points_scan", "int", 23, "limit number of points in scan data output", "", &PFDriverR2000Config::max_num_points_scan)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __param_descriptions__.push_back(PFDriverR2000Config::AbstractParamDescriptionConstPtr(new PFDriverR2000Config::ParamDescription<int>("max_num_points_scan", "int", 23, "limit number of points in scan data output", "", &PFDriverR2000Config::max_num_points_scan)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __min__.skip_scans = -2147483648;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __max__.skip_scans = 2147483647;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __default__.skip_scans = 0;
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      Default.abstract_parameters.push_back(PFDriverR2000Config::AbstractParamDescriptionConstPtr(new PFDriverR2000Config::ParamDescription<int>("skip_scans", "int", 24, "reduce scan output rate to every (n+1)th scan", "", &PFDriverR2000Config::skip_scans)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __param_descriptions__.push_back(PFDriverR2000Config::AbstractParamDescriptionConstPtr(new PFDriverR2000Config::ParamDescription<int>("skip_scans", "int", 24, "reduce scan output rate to every (n+1)th scan", "", &PFDriverR2000Config::skip_scans)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __min__.user_tag = "";
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __max__.user_tag = "";
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __default__.user_tag = "";
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      Default.abstract_parameters.push_back(PFDriverR2000Config::AbstractParamDescriptionConstPtr(new PFDriverR2000Config::ParamDescription<std::string>("user_tag", "str", 25, "User defined name (max. 32 chars)", "", &PFDriverR2000Config::user_tag)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __param_descriptions__.push_back(PFDriverR2000Config::AbstractParamDescriptionConstPtr(new PFDriverR2000Config::ParamDescription<std::string>("user_tag", "str", 25, "User defined name (max. 32 chars)", "", &PFDriverR2000Config::user_tag)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __min__.user_notes = "";
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __max__.user_notes = "";
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __default__.user_notes = "";
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      Default.abstract_parameters.push_back(PFDriverR2000Config::AbstractParamDescriptionConstPtr(new PFDriverR2000Config::ParamDescription<std::string>("user_notes", "str", 26, "User notes (max. 1000 Byte)", "", &PFDriverR2000Config::user_notes)));
//#line 291 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __param_descriptions__.push_back(PFDriverR2000Config::AbstractParamDescriptionConstPtr(new PFDriverR2000Config::ParamDescription<std::string>("user_notes", "str", 26, "User notes (max. 1000 Byte)", "", &PFDriverR2000Config::user_notes)));
//#line 246 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      Default.convertParams();
//#line 246 "/opt/ros/noetic/lib/python3/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __group_descriptions__.push_back(PFDriverR2000Config::AbstractGroupDescriptionConstPtr(new PFDriverR2000Config::GroupDescription<PFDriverR2000Config::DEFAULT, PFDriverR2000Config>(Default)));
//#line 369 "/opt/ros/noetic/share/dynamic_reconfigure/cmake/../templates/ConfigType.h.template"

      for (std::vector<PFDriverR2000Config::AbstractGroupDescriptionConstPtr>::const_iterator i = __group_descriptions__.begin(); i != __group_descriptions__.end(); ++i)
      {
        __description_message__.groups.push_back(**i);
      }
      __max__.__toMessage__(__description_message__.max, __param_descriptions__, __group_descriptions__);
      __min__.__toMessage__(__description_message__.min, __param_descriptions__, __group_descriptions__);
      __default__.__toMessage__(__description_message__.dflt, __param_descriptions__, __group_descriptions__);
    }
    std::vector<PFDriverR2000Config::AbstractParamDescriptionConstPtr> __param_descriptions__;
    std::vector<PFDriverR2000Config::AbstractGroupDescriptionConstPtr> __group_descriptions__;
    PFDriverR2000Config __max__;
    PFDriverR2000Config __min__;
    PFDriverR2000Config __default__;
    dynamic_reconfigure::ConfigDescription __description_message__;

    static const PFDriverR2000ConfigStatics *get_instance()
    {
      // Split this off in a separate function because I know that
      // instance will get initialized the first time get_instance is
      // called, and I am guaranteeing that get_instance gets called at
      // most once.
      static PFDriverR2000ConfigStatics instance;
      return &instance;
    }
  };

  inline const dynamic_reconfigure::ConfigDescription &PFDriverR2000Config::__getDescriptionMessage__()
  {
    return __get_statics__()->__description_message__;
  }

  inline const PFDriverR2000Config &PFDriverR2000Config::__getDefault__()
  {
    return __get_statics__()->__default__;
  }

  inline const PFDriverR2000Config &PFDriverR2000Config::__getMax__()
  {
    return __get_statics__()->__max__;
  }

  inline const PFDriverR2000Config &PFDriverR2000Config::__getMin__()
  {
    return __get_statics__()->__min__;
  }

  inline const std::vector<PFDriverR2000Config::AbstractParamDescriptionConstPtr> &PFDriverR2000Config::__getParamDescriptions__()
  {
    return __get_statics__()->__param_descriptions__;
  }

  inline const std::vector<PFDriverR2000Config::AbstractGroupDescriptionConstPtr> &PFDriverR2000Config::__getGroupDescriptions__()
  {
    return __get_statics__()->__group_descriptions__;
  }

  inline const PFDriverR2000ConfigStatics *PFDriverR2000Config::__get_statics__()
  {
    const static PFDriverR2000ConfigStatics *statics;

    if (statics) // Common case
      return statics;

    boost::mutex::scoped_lock lock(dynamic_reconfigure::__init_mutex__);

    if (statics) // In case we lost a race.
      return statics;

    statics = PFDriverR2000ConfigStatics::get_instance();

    return statics;
  }

//#line 11 "/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2000.cfg"
      const int PFDriverR2000_static = 0;
//#line 12 "/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2000.cfg"
      const int PFDriverR2000_dhcp = 1;
//#line 13 "/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2000.cfg"
      const int PFDriverR2000_autoip = 2;
//#line 21 "/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2000.cfg"
      const char * const PFDriverR2000_cw = "cw";
//#line 22 "/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2000.cfg"
      const char * const PFDriverR2000_ccw = "ccw";
//#line 26 "/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2000.cfg"
      const int PFDriverR2000_samples_per_scan_72 = 72;
//#line 27 "/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2000.cfg"
      const int PFDriverR2000_samples_per_scan_90 = 90;
//#line 28 "/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2000.cfg"
      const int PFDriverR2000_samples_per_scan_120 = 120;
//#line 29 "/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2000.cfg"
      const int PFDriverR2000_samples_per_scan_144 = 144;
//#line 30 "/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2000.cfg"
      const int PFDriverR2000_samples_per_scan_180 = 180;
//#line 31 "/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2000.cfg"
      const int PFDriverR2000_samples_per_scan_240 = 240;
//#line 32 "/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2000.cfg"
      const int PFDriverR2000_samples_per_scan_360 = 360;
//#line 33 "/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2000.cfg"
      const int PFDriverR2000_samples_per_scan_400 = 400;
//#line 34 "/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2000.cfg"
      const int PFDriverR2000_samples_per_scan_480 = 480;
//#line 35 "/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2000.cfg"
      const int PFDriverR2000_samples_per_scan_600 = 600;
//#line 36 "/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2000.cfg"
      const int PFDriverR2000_samples_per_scan_720 = 720;
//#line 37 "/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2000.cfg"
      const int PFDriverR2000_samples_per_scan_800 = 800;
//#line 38 "/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2000.cfg"
      const int PFDriverR2000_samples_per_scan_900 = 900;
//#line 39 "/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2000.cfg"
      const int PFDriverR2000_samples_per_scan_1200 = 1200;
//#line 40 "/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2000.cfg"
      const int PFDriverR2000_samples_per_scan_1440 = 1440;
//#line 41 "/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2000.cfg"
      const int PFDriverR2000_samples_per_scan_1680 = 1680;
//#line 42 "/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2000.cfg"
      const int PFDriverR2000_samples_per_scan_1800 = 1800;
//#line 43 "/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2000.cfg"
      const int PFDriverR2000_samples_per_scan_2100 = 2100;
//#line 44 "/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2000.cfg"
      const int PFDriverR2000_samples_per_scan_2400 = 2400;
//#line 45 "/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2000.cfg"
      const int PFDriverR2000_samples_per_scan_2520 = 2520;
//#line 46 "/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2000.cfg"
      const int PFDriverR2000_samples_per_scan_2800 = 2800;
//#line 47 "/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2000.cfg"
      const int PFDriverR2000_samples_per_scan_3150 = 3150;
//#line 48 "/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2000.cfg"
      const int PFDriverR2000_samples_per_scan_3600 = 3600;
//#line 49 "/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2000.cfg"
      const int PFDriverR2000_samples_per_scan_4200 = 4200;
//#line 50 "/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2000.cfg"
      const int PFDriverR2000_samples_per_scan_5040 = 5040;
//#line 51 "/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2000.cfg"
      const int PFDriverR2000_samples_per_scan_5600 = 5600;
//#line 52 "/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2000.cfg"
      const int PFDriverR2000_samples_per_scan_6300 = 6300;
//#line 53 "/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2000.cfg"
      const int PFDriverR2000_samples_per_scan_7200 = 7200;
//#line 54 "/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2000.cfg"
      const int PFDriverR2000_samples_per_scan_8400 = 8400;
//#line 55 "/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2000.cfg"
      const int PFDriverR2000_samples_per_scan_10800 = 10080;
//#line 56 "/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2000.cfg"
      const int PFDriverR2000_samples_per_scan_12600 = 12600;
//#line 57 "/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2000.cfg"
      const int PFDriverR2000_samples_per_scan_16800 = 16800;
//#line 58 "/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2000.cfg"
      const int PFDriverR2000_samples_per_scan_25200 = 25200;
//#line 63 "/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2000.cfg"
      const char * const PFDriverR2000_hmi_display_off = "off";
//#line 64 "/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2000.cfg"
      const char * const PFDriverR2000_static_logo = "static_logo";
//#line 65 "/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2000.cfg"
      const char * const PFDriverR2000_static_text = "static_text";
//#line 66 "/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2000.cfg"
      const char * const PFDriverR2000_bargraph_distance = "bargraph_distance";
//#line 67 "/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2000.cfg"
      const char * const PFDriverR2000_bargraph_echo = "bargraph_echo";
//#line 68 "/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2000.cfg"
      const char * const PFDriverR2000_bargraph_reflector = "bargraph_reflector";
//#line 69 "/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2000.cfg"
      const char * const PFDriverR2000_application_bitmap = "application_bitmap";
//#line 70 "/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2000.cfg"
      const char * const PFDriverR2000_application_text = "application_text";
//#line 74 "/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2000.cfg"
      const char * const PFDriverR2000_english = "english";
//#line 75 "/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2000.cfg"
      const char * const PFDriverR2000_german = "german";
//#line 79 "/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2000.cfg"
      const char * const PFDriverR2000_hmi_button_lock_on = "on";
//#line 80 "/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2000.cfg"
      const char * const PFDriverR2000_hmi_button_lock_off = "off";
//#line 84 "/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2000.cfg"
      const char * const PFDriverR2000_hmi_parameter_lock_on = "on";
//#line 85 "/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2000.cfg"
      const char * const PFDriverR2000_hmi_parameter_lock_off = "off";
//#line 91 "/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2000.cfg"
      const char * const PFDriverR2000_locator_indicator_on = "on";
//#line 92 "/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2000.cfg"
      const char * const PFDriverR2000_locator_indicator_off = "off";
//#line 96 "/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2000.cfg"
      const char * const PFDriverR2000_measure = "measure";
//#line 97 "/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2000.cfg"
      const char * const PFDriverR2000_emitter_off = "emitter_off";
//#line 103 "/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2000.cfg"
      const char * const PFDriverR2000_packet_type_A = "A";
//#line 104 "/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2000.cfg"
      const char * const PFDriverR2000_packet_type_B = "B";
//#line 105 "/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2000.cfg"
      const char * const PFDriverR2000_packet_type_C = "C";
//#line 109 "/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2000.cfg"
      const char * const PFDriverR2000_watchdog_on = "on";
//#line 110 "/home/dal/ros1_ws/src/pf_lidar_ros_driver/pf_driver/cfg/PFDriverR2000.cfg"
      const char * const PFDriverR2000_watchdog_off = "off";
}

#undef DYNAMIC_RECONFIGURE_FINAL

#endif // __PFDRIVERR2000RECONFIGURATOR_H__
